import { Sandbox } from "@e2b/code-interpreter";
import {
  createAgent,
  createNetwork,
  createState,
  createTool,
  type Message,
  type Tool,
} from "@inngest/agent-kit";
import { z } from "zod";

import prisma from "@/lib/prisma";
import { inngest } from "@/inngest/client";
import { FileCollection } from "@/types";
import { EDIT_PROMPT, FRAGMENT_TITLE_PROMPT, PROMPT, RESPONSE_PROMPT, TASK_STEPS_PROMPT } from "@/prompt";

import { SANDBOX_TIMEOUT_IN_MS } from "@/constants";
import { getSandbox, parseAgentOutput, lastAssistantTextMessageContent, logAssistantTexts, azureOpenAICompat, normalizeSandboxPath, shouldBlockDestructivePageWrite, normalizeAppFileContent, upsertMetadataInLayout, type AzureCompatOptions } from "@/inngest/utils";
const DEFAULT_NEXT_TEMPLATE_RE = /Learn\s+Next\.js|By\s+vercel|next\.svg|create-next-app|Generated by create next app/i;

type AgentState = {
  summary: string;
  files: Record<string, string>;
  allowedPaths?: string[];
};

async function getOrCreateSandboxId(step: any) {
  return await step.run("get-sandbox-id", async () => {
    const template =
      process.env.E2B_TEMPLATE_ID ||
      process.env.E2B_TEMPLATE_NAME ||
      "lovable-clone-nextjs-sg-0206";
    console.log("Creating E2B sandbox using template:", template);
    try {
      const sandbox = await Sandbox.create(template);
      await sandbox.setTimeout(SANDBOX_TIMEOUT_IN_MS);
      console.log("‚úÖ Sandbox created:", sandbox.sandboxId);
      return sandbox.sandboxId;
    } catch (err: any) {
      console.error("‚ùå Failed to create E2B sandbox:", err?.message);
      throw err;
    }
  });
}

function createTaskStepsAgent() {
  return createAgent({
    name: "task-steps-generator",
    description: "A task steps generator",
    system: TASK_STEPS_PROMPT,
    model: azureOpenAICompat({
      endpoint: process.env.AZURE_OPENAI_ENDPOINT!,
      apiKey: process.env.AZURE_OPENAI_API_KEY!,
      deployment: process.env.AZURE_OPENAI_4_1_DEPLOYMENT!,
      apiVersion: process.env.AZURE_OPENAI_4_1_API_VERSION!,
      defaultParameters: { temperature: 0.1 },
    }),
  });
}

function createFragmentTitleAgent() {
  return createAgent({
    name: "fragment-title-generator",
    description: "A fragment title generator",
    system: FRAGMENT_TITLE_PROMPT,
    model: azureOpenAICompat({
      endpoint: process.env.AZURE_OPENAI_ENDPOINT!,
      apiKey: process.env.AZURE_OPENAI_5_API_KEY || process.env.AZURE_OPENAI_API_KEY!,
      deployment: process.env.AZURE_OPENAI_5_DEPLOYMENT || process.env.AZURE_OPENAI_DEPLOYMENT!,
      apiVersion: process.env.AZURE_OPENAI_5_API_VERSION || process.env.AZURE_OPENAI_API_VERSION!,
      defaultParameters: { temperature: 0.1 },
    }),
  });
}

function createResponseAgent() {
  return createAgent({
    name: "response-generator",
    description: "Generates the user-facing summary message",
    system: RESPONSE_PROMPT,
    model: azureOpenAICompat({
      endpoint: process.env.AZURE_OPENAI_ENDPOINT!,
      apiKey: process.env.AZURE_OPENAI_API_KEY!,
      deployment: process.env.AZURE_OPENAI_4_1_DEPLOYMENT!,
      apiVersion: process.env.AZURE_OPENAI_4_1_API_VERSION!,
      defaultParameters: { temperature: 0.1 },
    }),
  });
}

async function ensureMetadataStep(step: any, result: any, sandboxId: string, title: string, description: string) {
  await step.run("ensure-metadata", async () => {
    if (!result?.state?.data) return;
    
    const files = (result.state.data.files || {}) as Record<string, string>;
    const sandbox = await getSandbox(sandboxId);
    const layoutPath = "app/layout.tsx";

    let currentContent = files[layoutPath] || "";
    if (!currentContent) {
      try {
        currentContent = await sandbox.files.read(layoutPath) || "";
      } catch {
        currentContent = "";
      }
    }
    
    const updatedContent = upsertMetadataInLayout(currentContent, title, description);
    
    if (updatedContent !== currentContent) {
      await sandbox.files.write(layoutPath, updatedContent);
      files[layoutPath] = updatedContent;
    }
  });
}

export const codeAgentFunction = inngest.createFunction(
  { id: "code-agent" },
  { event: "code-agent/run" },
  async ({ event, step }) => {
    console.log("üîß Starting code-agent function");
    const sandboxId = await getOrCreateSandboxId(step);

    const previousMessages = await step.run(
      "get-previous-messages",
      async () => {
        const formattedMessages: Message[] = [];

        const messages = await prisma.message.findMany({
          where: {
            projectId: event.data.projectId,
          },
          orderBy: {
            createdAt: "desc",
          },
          take: 5,
        });

        for (const message of messages) {
          formattedMessages.push({
            type: "text",
            role: message.role === "ASSISTANT" ? "assistant" : "user",
            content: message.content,
          });
        }
        console.log("üìù Loaded", formattedMessages.length, "previous messages");
        return formattedMessages.reverse();
      }
    );

    const state = createState<AgentState>(
      {
        summary: "",
        files: {},
      },
      {
        messages: previousMessages,
      }
    );

    const codeAgent = createAgent<AgentState>({
      name: "code-agent",
      description: "An expert coding agent",
      system: PROMPT,
      model: azureOpenAICompat({
        endpoint: process.env.AZURE_OPENAI_ENDPOINT!,
        apiKey: process.env.AZURE_OPENAI_5_API_KEY || process.env.AZURE_OPENAI_API_KEY!,
        deployment: process.env.AZURE_OPENAI_5_DEPLOYMENT || process.env.AZURE_OPENAI_DEPLOYMENT!,
        apiVersion: process.env.AZURE_OPENAI_5_API_VERSION || process.env.AZURE_OPENAI_API_VERSION!,
        defaultParameters: { temperature: 0.1 },
      }),
      tools: [
        createTool({
          name: "terminal",
          description: "Use the terminal to run commands",
          parameters: z.object({ command: z.string() }),
          handler: async ({ command }, { step }) => {
            console.log("‚ö° Running command:", command);
            return await step?.run("terminal", async () => {
              const buffers = { stdout: "", stderr: "" };
              try {
                const sandbox = await getSandbox(sandboxId);
                const result = await sandbox.commands.run(command, {
                  onStdout: (data: string) => { buffers.stdout += data; },
                  onStderr: (data: string) => { buffers.stderr += data; },
                });
                console.log("‚úÖ Command completed with exit code:", result.exitCode);
                return result.stdout;
              } catch (error) {
                console.error(`‚ùå Command failed: ${error}`);
                return `command failed: ${error}\nstdOut: ${buffers.stdout}\nstdError: ${buffers.stderr}`;
              }
            });
          },
        }),
        createTool({
          name: "createOrUpdateFiles",
          description: "Create or update files in the sandbox",
          parameters: z.object({
            files: z.array(z.object({ path: z.string(), content: z.string() })),
          }),
          handler: async ({ files }, { step, network }: Tool.Options<AgentState>) => {
            console.log("üìù Creating/updating", files.length, "files");
            const newFiles = await step?.run("createOrUpdateFiles", async () => {
              try {
                const updatedFiles = network.state.data.files || {};
                const sandbox = await getSandbox(sandboxId);
                const hasSrc = Object.keys(updatedFiles).some((p) => p.startsWith("src/"));
                const guard = new Set<string>((network.state.data.allowedPaths || []) as string[]);
                for (const file of files) {
                  let normalized = normalizeSandboxPath(file.path, hasSrc);
                  if (!normalized) {
                    console.warn(`üö´ Invalid path: ${file.path}`);
                    continue;
                  }
                  
                  const guard = new Set<string>((network.state.data.allowedPaths || []) as string[]);
                  if (guard.size > 0 && !guard.has(normalized) && 
                      !Array.from(guard).some(g => 
                        (g.endsWith("/*") && normalized.startsWith(g.slice(0, -2))) ||
                        (g.endsWith("/") && normalized.startsWith(g))
                      )) {
                    console.warn(`üö´ Blocked write to ${normalized}`);
                    continue;
                  }
                  if (/^app\/page\.(tsx|jsx|ts|js)$/i.test(normalized)) {
                    const prev = typeof updatedFiles[normalized] === "string"
                      ? (updatedFiles[normalized] as string)
                      : await (async () => { try { return await sandbox.files.read(normalized); } catch { return ""; } })();
                    if (shouldBlockDestructivePageWrite(prev || "", file.content)) {
                      console.warn("üö´ Blocked destructive overwrite of app/page.*");
                      return `Blocked destructive overwrite of ${normalized}. Use safeUpdatePage tool to insert new hero without removing existing content.`;
                    }
                  }
                  if (/\/demo\.(tsx|jsx|ts|js)$/i.test(normalized)) {
                    console.warn(`üö´ Demo files not allowed: ${normalized}`);
                    continue;
                  }
                  if (/app\/page\.(tsx|jsx|ts|js)$/i.test(normalized) && DEFAULT_NEXT_TEMPLATE_RE.test(file.content)) {
                    console.warn("üö´ Skipping Next.js starter content overwrite");
                    continue;
                  }
                  const finalContent = normalizeAppFileContent(normalized, file.content);
                  await sandbox.files.write(normalized, finalContent);
                  updatedFiles[normalized] = finalContent;
                }
                console.log("‚úÖ Files created/updated successfully");
                return updatedFiles;
              } catch (error) {
                console.error("‚ùå Error in createOrUpdateFiles:", error);
                return "Error: " + error;
              }
            });
            if (typeof newFiles === "object") {
              const prev = (network.state.data.files || {}) as Record<string, string>;
              network.state.data.files = { ...prev, ...(newFiles as any) } as any;
            }
          },
        }),
        createTool({
          name: "safeUpdatePage",
          description: "Non-destructive update for app/page.*. Inserts a component into <main> and ensures import; preserves the rest of the file.",
          parameters: z.object({
            filePath: z.string().default("app/page.tsx"),
            importLine: z.string(),
            jsx: z.string(),
            position: z.enum(["prepend", "append"]).default("append"),
          }),
          handler: async ({ filePath, importLine, jsx, position }, { step, network }) => {
            return await step?.run("safeUpdatePage", async () => {
              const sandbox = await getSandbox(sandboxId);
              const filesState = network.state.data.files || {};
              const hasSrc = Object.keys(filesState).some((p) => p.startsWith("src/")) ||
                (await (async () => { try { await sandbox.files.read("src/app/page.tsx"); return true; } catch { return false; } })());
              const path = normalizeSandboxPath(filePath, hasSrc);
              if (!path) return `Invalid path: ${filePath}`;
              const guard = new Set<string>((network.state.data.allowedPaths || []) as string[]);
              if (guard.size > 0 && !guard.has(path) && 
                  !Array.from(guard).some(g => 
                    (g.endsWith("/*") && path.startsWith(g.slice(0, -2))) ||
                    (g.endsWith("/") && path.startsWith(g))
                  )) return `Blocked: ${path} not in allowedPaths.`;
              let prev = "";
              try { prev = await sandbox.files.read(path); } catch {}
              // If file missing or it's the default Next.js starter, start from a minimal shell
              if (!prev || DEFAULT_NEXT_TEMPLATE_RE.test(prev)) {
                prev = `"use client";\n\nexport default function Page(){\n  return (<main className=\"min-h-screen w-full\"></main>);\n}\n`;
              }
              // Simplified approach: just add import and jsx without complex processing
              let next = prev;
              if (importLine?.trim() && !prev.includes(importLine.trim())) {
                const lines = prev.split("\n");
                let insertIdx = 0;
                if (/^\s*['"]use client['"]\s*;?/.test(lines[0] || "")) insertIdx = 1;
                for (let i = insertIdx; i < lines.length; i++) {
                  if (/^\s*import\s+/.test(lines[i])) insertIdx = i + 1;
                  else if (lines[i].trim() && !/^\s*(\/\*|\/\/)/.test(lines[i])) break;
                }
                lines.splice(insertIdx, 0, importLine.trim());
                next = lines.join("\n");
              }
              // Insert JSX into main tag or at the end
              const mainMatch = next.match(/<main\b[^>]*>([\s\S]*?)<\/main>/i);
              if (mainMatch) {
                const mainContent = mainMatch[1];
                const newMainContent = position === "prepend" 
                  ? `\n      ${jsx}\n${mainContent}` 
                  : `${mainContent}\n      ${jsx}\n`;
                next = next.replace(/<main\b[^>]*>[\s\S]*?<\/main>/i, 
                  mainMatch[0].replace(mainContent, newMainContent));
              } else {
                next = next + `\n${jsx}\n`;
              }
              await sandbox.files.write(path, next);
              network.state.data.files[path] = next;
              return `Updated ${path} with safe merge`;
            });
          },
        }),
        createTool({
          name: "readFiles",
          description: "Read files from the sandbox",
          parameters: z.object({ files: z.array(z.string()) }),
          handler: async ({ files }, { step, network }) => {
            console.log("üìñ Reading", files.length, "files");
            return await step?.run("readFiles", async () => {
              try {
                const sandbox = await getSandbox(sandboxId);
                const existing = network.state.data.files || {};
                const hasSrc = Object.keys(existing).some((p) => p.startsWith("src/"));
                const contents: { path: string; content: string | null }[] = [];
                for (const raw of files) {
                  const p = normalizeSandboxPath(raw, hasSrc);
                  if (!p) {
                    contents.push({ path: raw, content: null });
                    continue;
                  }
                  try {
                    const content = await sandbox.files.read(p);
                    contents.push({ path: p, content });
                  } catch (e: any) {
                    const msg = String(e?.message || e);
                    if (/NotFound/i.test(msg)) {
                      console.warn(`üìÑ File not found: ${p}`);
                      contents.push({ path: p, content: null });
                      continue;
                    }
                    throw e;
                  }
                }
                console.log("‚úÖ Read", contents.length, "files successfully");
                return JSON.stringify(contents);
              } catch (error) {
                console.error("‚ùå Error in readFiles:", error);
                return "Error: " + error;
              }
            });
          },
        }),
      ],
      lifecycle: {
        onResponse: async ({ result, network }) => {
          logAssistantTexts("code-agent", result.output);
          const lastAssistantTextMessageText = lastAssistantTextMessageContent(result);
          if (lastAssistantTextMessageText && network) {
            if (lastAssistantTextMessageText.includes("<task_summary>")) {
              network.state.data.summary = lastAssistantTextMessageText;
            }
          }
          return result;
        },
      },
    });

    const network = createNetwork<AgentState>({
      name: "coding-agent-network",
      agents: [codeAgent],
      maxIter: 15,
      defaultState: state,
      router: async ({ network }) => {
        const summary = network.state.data.summary;

        if (summary) {
          console.log("üèÅ Task completed, ending");
          return;
        }
        console.log("üîÑ Routing to code agent");
        return codeAgent;
      },
    });

    // Compose an enriched instruction including customization
    const customization = (event.data as any).customization as
      | {
          analytics?: { provider: string; code?: string };
          components?: Record<string, { enabled: boolean; prompt?: string; border?: { enabled: boolean; prompt?: string } }>;
          theme?: { paletteId: string; paletteName: string; colors: string[] };
        }
      | undefined;

    const selectedComponents = Object.entries(customization?.components || {})
      .filter(([, cfg]) => cfg.enabled)
      .map(([key, cfg]) => ({ key, prompt: cfg.prompt, borderPrompt: cfg.border?.prompt }));

    const enrichedInstruction = [
      event.data.value,
      selectedComponents.length
        ? `\n\nComponents to include (in order if applicable):\n${selectedComponents
            .map(
              (c, i) => ` ${i + 1}. ${c.key}${c.prompt ? `\n    prompt: ${c.prompt}` : ""}${c.borderPrompt ? `\n    border: ${c.borderPrompt}` : ""}`
            )
            .join("\n")}`
        : "",
      customization?.theme
        ? `\n\nColor palette (4 colors, use as base tokens): ${customization.theme.paletteName} ‚Äî ${customization.theme.colors.join(", ")}`
        : "",
      customization?.analytics && customization.analytics.provider !== "none"
        ? `\n\nAnalytics: ${customization.analytics.provider}${customization.analytics.code ? ` (${customization.analytics.code.slice(0, 40)}...)` : ""}`
        : "",
    ]
      .filter(Boolean)
      .join("");

    const taskStepsGenerator = createTaskStepsAgent();

    const { output: taskStepsOutput } = await taskStepsGenerator.run(
      enrichedInstruction
    );
    logAssistantTexts("task-steps-generator", taskStepsOutput);
    console.log("üìã Task steps generated");

    await step.run("save-steps", async () => {
      const stepsMessage = await prisma.message.create({
        data: {
          projectId: event.data.projectId,
          content: parseAgentOutput(taskStepsOutput),
          role: "ASSISTANT",
          type: "STEPS",
        },
      });
      console.log("üíæ Steps saved:", stepsMessage.id);
      return stepsMessage;
    });

    const result = await network.run(enrichedInstruction, { state });
    console.log("üéØ Network execution", result.state.data.summary ? "completed" : "failed");

  const fragmentTitleGenerator = createFragmentTitleAgent();

  const responseGenerator = createResponseAgent();

  const { output: fragmentTitleOutput } = await fragmentTitleGenerator.run(
      result.state.data.summary
    );
  logAssistantTexts("fragment-title-generator", fragmentTitleOutput);
    console.log("üè∑Ô∏è Fragment title generated");

  const { output: responseOutput } = await responseGenerator.run(
      result.state.data.summary
    );
  logAssistantTexts("response-generator", responseOutput);
    console.log("üìù Response generated");

    // Ensure project metadata (title/description) in app/layout.*
    const generatedTitle = parseAgentOutput(fragmentTitleOutput) || "Landing Page";
    await ensureMetadataStep(step, result, sandboxId, generatedTitle, "Landing Page criada no Landinfy.com");

    const isError =
      !result.state.data.summary ||
      Object.keys(result.state.data.files || {}).length === 0;

    // Best-effort analytics injection (Next.js App Router friendly)
    if (!isError && customization?.analytics && customization?.analytics?.provider !== "none") {
      await step.run("inject-analytics", async () => {
        try {
          console.log("üìä Injecting analytics");
          const rawSnippet = (customization?.analytics?.code || "").trim();
          if (!rawSnippet) return;

          // Parse one or more <script> tags; if none, treat as inline JS
          const scriptMatches = Array.from(rawSnippet.matchAll(/<script\b([^>]*)>([\s\S]*?)<\/script>/gi));
          const scripts = scriptMatches.length
            ? scriptMatches.map((mm) => ({ attrs: (mm[1] || "").trim(), content: (mm[2] || "").trim() }))
            : [{ attrs: "", content: rawSnippet }];

          const makePropsFromAttrs = (attrs: string) => {
            const idMatch = attrs.match(/\bid=["']([^"']+)["']/i);
            const srcMatch = attrs.match(/\bsrc=["']([^"']+)["']/i);
            const hasAsync = /\basync\b/i.test(attrs);
            const hasDefer = /\bdefer\b/i.test(attrs);
            const dataMatches = Array.from(attrs.matchAll(/\b(data-[\w-]+)=["']([^"']+)["']/gi));
            let props = `strategy="afterInteractive"`;
            if (idMatch?.[1]) props += ` id="${idMatch[1]}"`;
            if (srcMatch?.[1]) props += ` src="${srcMatch[1]}"`;
            if (hasAsync) props += ` async`;
            if (hasDefer) props += ` defer`;
            for (const m of dataMatches) {
              const k = m[1];
              const v = m[2];
              props += ` ${k}="${v}"`;
            }
            return { props, hasSrc: !!srcMatch?.[1] };
          };

          const files = result.state.data.files || {};
          const sandbox = await getSandbox(sandboxId);

          // Try to find layout both in memory and in sandbox
          const inMemory = Object.keys(files).find((p) => /^(src\/)?app\/layout\.(tsx|jsx|ts|js)$/i.test(p));
          const candidates = [
            "src/app/layout.tsx","src/app/layout.jsx","src/app/layout.ts","src/app/layout.js",
            "app/layout.tsx","app/layout.jsx","app/layout.ts","app/layout.js",
          ];
          let layoutPath = inMemory;
          let layoutRaw = layoutPath ? String(files[layoutPath] || "") : "";
          if (!layoutPath || !layoutRaw) {
            for (const p of candidates) {
              try {
                const r = await sandbox.files.read(p);
                if (r && typeof r === "string") { layoutPath = p; layoutRaw = r; break; }
              } catch {}
            }
          }

          if (layoutPath && layoutRaw) {
            // 1) Write analytics component alongside layout (supports src/ and non-src projects)
            const hasSrc = /^src\//i.test(layoutPath);
            const analyticsPath = hasSrc ? "src/app/analytics.tsx" : "app/analytics.tsx";
            // Build one <Script> per parsed <script> tag
            const lines = scripts
              .map((s, idx) => {
                const { props, hasSrc } = makePropsFromAttrs(s.attrs);
                if (hasSrc) {
                  return `      <Script ${props} />`;
                }
                const escaped = s.content
                  .replace(/`/g, "\\`")
                  .replace(/\$\{/g, "\\${");
                const needsId = !/\bid=/.test(props);
                const idProp = needsId ? ` id={\"custom-analytics-${idx}\"}` : "";
                return `      <Script ${props}${idProp} dangerouslySetInnerHTML={{ __html: \`${escaped}\` }} />`;
              })
              .join("\n");
            const analyticsContent = `"use client";\nimport Script from 'next/script';\nexport default function AppAnalytics() {\n  return (\n    <>\n${lines}\n    </>\n  );\n}\n`;
            await sandbox.files.write(analyticsPath, analyticsContent);
            result.state.data.files[analyticsPath] = analyticsContent;

            // 2) Inject import and <AppAnalytics /> into layout
            let nextLayout = layoutRaw;
            const hasImport = /from\s+['"]\.\/analytics['"]/m.test(nextLayout);
            if (!hasImport) {
              if (/^import\s/m.test(nextLayout)) {
                nextLayout = nextLayout.replace(/^(import[\s\S]*?;\s*)/m, `$1\nimport AppAnalytics from './analytics';\n`);
              } else {
                nextLayout = `import AppAnalytics from './analytics';\n` + nextLayout;
              }
            }
            if (!/\<AppAnalytics\s*\/>/m.test(nextLayout)) {
              const bodyIdx = nextLayout.search(/<body[^>]*>/i);
              if (bodyIdx !== -1) {
                const insertPos = nextLayout.indexOf('>', bodyIdx) + 1;
                nextLayout = nextLayout.slice(0, insertPos) + `\n      <AppAnalytics />` + nextLayout.slice(insertPos);
              } else {
                nextLayout = nextLayout.replace(/(\{\s*children\s*\})/m, `<AppAnalytics />\n      $1`);
              }
            }
            await sandbox.files.write(layoutPath, nextLayout);
            result.state.data.files[layoutPath] = nextLayout;
            console.log("‚úÖ Analytics injected via layout");
            return;
          }

          // Fallbacks: try raw head injection or create app/head.tsx based on in-memory files
          const buildRawScriptTag = (attrs: string, content: string) => {
            const idMatch = attrs.match(/\bid=["']([^"']+)["']/i);
            const srcMatch = attrs.match(/\bsrc=["']([^"']+)["']/i);
            const hasAsync = /\basync\b/i.test(attrs);
            const hasDefer = /\bdefer\b/i.test(attrs);
            const dataMatches = Array.from(attrs.matchAll(/\b(data-[\w-]+)=["']([^"']+)["']/gi));
            let attrStr = "";
            if (idMatch?.[1]) attrStr += ` id=\"${idMatch[1]}\"`;
            if (srcMatch?.[1]) attrStr += ` src=\"${srcMatch[1]}\"`;
            if (hasAsync) attrStr += ` async`;
            if (hasDefer) attrStr += ` defer`;
            for (const m of dataMatches) {
              const k = m[1];
              const v = m[2];
              attrStr += ` ${k}=\"${v}\"`;
            }
            if (srcMatch?.[1]) {
              return `<script${attrStr}></script>`;
            }
            // Escape closing script tags if present in content to avoid early termination
            const safeContent = content.replace(/<\/script>/gi, "<\\/script>");
            return `<script${attrStr}>\n${safeContent}\n</script>`;
          };

          const headScriptsHtml = scripts.map((s) => buildRawScriptTag(s.attrs, s.content)).join("\n");

          let targetPath: string | undefined;
          let updatedContent: string | undefined;
          for (const [p, content] of Object.entries(files)) {
            const c = String(content || "");
            if (c.includes("</head>")) {
              updatedContent = c.replace(/<\/head>/i, `\n  {/* Analytics */}\n${headScriptsHtml}\n</head>`);
              targetPath = p;
              break;
            }
          }
          if (!updatedContent) {
            targetPath = "app/head.tsx";
            const joined = headScriptsHtml;
            updatedContent = `export default function Head() {\n  return (\n    <>\n      {/* Analytics */}\n      <>${joined}</>\n    </>\n  );\n}\n`;
          }
          if (targetPath && updatedContent) {
            await sandbox.files.write(targetPath, updatedContent);
            result.state.data.files[targetPath] = updatedContent;
            console.log("‚úÖ Analytics injected via head fallback");
          }
        } catch (err) {
          console.warn("Analytics injection failed", err);
        }
      });
    }

    // Cleanup: remove orphan ClarityAnalytics component files if present
    if (!isError) {
      await step.run("cleanup-orphan-analytics", async () => {
        try {
          const sandbox = await getSandbox(sandboxId);
          try {
            await sandbox.commands.run("bash -lc \"rm -f app/ClarityAnalytics.tsx src/app/ClarityAnalytics.tsx\"");
          } catch {}
          const files = (result.state.data.files || {}) as Record<string, string>;
          delete files["app/ClarityAnalytics.tsx"];
          delete files["src/app/ClarityAnalytics.tsx"];
        } catch (e) {
          console.warn("cleanup-orphan-analytics failed", e);
        }
      });
    }

    // Post-process: fix common export issues (versions, tailwind/shadcn, missing UI stubs)
    if (!isError) {
      await step.run("postprocess-project", async () => {
        const sandbox = await getSandbox(sandboxId);

        // Helper: safe read
        const readSafe = async (p: string) => {
          try {
            return await sandbox.files.read(p);
          } catch {
            return undefined;
          }
        };

        // 0) Ensure 'use client' directive is the very first line when present
        try {
          const moveUseClientToTop = (src: string) => {
            if (!/['"]use client['"]/m.test(src)) return src;
            // Remove all occurrences of the directive and re-insert at the top
            const withoutAll = src.replace(/^[\s;]*["']use client["']\s*;?\s*/gm, "");
            return `"use client";\n` + withoutAll.replace(/^\s+/, "");
          };
          const entries = Object.entries(result.state.data.files || {});
          for (const [path, content] of entries) {
            if (typeof content !== "string") continue;
            if (!/\.(tsx|jsx)$/i.test(path)) continue;
            const fixed = moveUseClientToTop(content);
            if (fixed !== content) {
              await sandbox.files.write(path, fixed);
              result.state.data.files[path] = fixed;
            }
          }
        } catch (e) {
          console.warn("postprocess: move 'use client' to top failed", e);
        }

        // 1) Sanitize package.json: versions like ^latest/~latest, invalid package names, fix next-themes
        try {
          const pkgPath = "package.json";
          const pkgRaw = await readSafe(pkgPath);
          if (pkgRaw) {
            const pkg = JSON.parse(pkgRaw);
            const fix = (deps?: Record<string, string>) => {
              if (!deps) return;
              for (const k of Object.keys(deps)) {
                const v = deps[k];
                // Remove clearly invalid package names (import paths accidentally added to deps)
                if (/\//.test(k) && !k.startsWith("@")) {
                  delete deps[k];
                  continue;
                }
                if (k === "next/font/google" || k === "motion/react") {
                  delete deps[k];
                  continue;
                }
                // Normalize invalid tags
                if (typeof v === "string") {
                  const vv = v.trim();
                  if (/^\^latest$/i.test(vv) || /^~latest$/i.test(vv)) {
                    deps[k] = "latest";
                  }
                  // next-themes bogus versions ‚Äì set to a known good range
                  if (k === "next-themes") {
                    if (!/^\d/.test(vv) && !/^~?\^?\d/.test(vv)) {
                      deps[k] = "^0.3.0";
                    }
                  }
                }
              }
            };
            fix(pkg.dependencies);
            fix(pkg.devDependencies);
            fix(pkg.peerDependencies);
            fix(pkg.optionalDependencies);
            const nextRaw = JSON.stringify(pkg, null, 2) + "\n";
            if (nextRaw !== pkgRaw) {
              await sandbox.files.write(pkgPath, nextRaw);
              result.state.data.files[pkgPath] = nextRaw;
            }
          }
        } catch (e) {
          console.warn("postprocess: package.json sanitize failed", e);
        }

        // 2) Ensure Tailwind config and shadcn tokens (prefer CJS for compatibility)
        try {
          const twPaths = [
            "tailwind.config.cjs",
            "tailwind.config.js",
            "tailwind.config.mjs",
            "tailwind.config.ts",
          ];
          let twPath: string | undefined;
          let twRaw: string | undefined;
          for (const p of twPaths) {
            const r = await readSafe(p);
            if (r) {
              twPath = p;
              twRaw = r;
              break;
            }
          }
          const shadcnTwCjs = `/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  darkMode: ['class'],\n  content: [\n    './app/**/*.{ts,tsx}',\n    './components/**/*.{ts,tsx}',\n    './pages/**/*.{ts,tsx}',\n    './src/**/*.{ts,tsx}',\n  ],\n  theme: {\n    extend: {\n      colors: {\n        border: 'hsl(var(--border))',\n        input: 'hsl(var(--input))',\n        ring: 'hsl(var(--ring))',\n        background: 'hsl(var(--background))',\n        foreground: 'hsl(var(--foreground))',\n        primary: { DEFAULT: 'hsl(var(--primary))', foreground: 'hsl(var(--primary-foreground))' },\n        secondary: { DEFAULT: 'hsl(var(--secondary))', foreground: 'hsl(var(--secondary-foreground))' },\n        destructive: { DEFAULT: 'hsl(var(--destructive))', foreground: 'hsl(var(--destructive-foreground))' },\n        muted: { DEFAULT: 'hsl(var(--muted))', foreground: 'hsl(var(--muted-foreground))' },\n        accent: { DEFAULT: 'hsl(var(--accent))', foreground: 'hsl(var(--accent-foreground))' },\n        popover: { DEFAULT: 'hsl(var(--popover))', foreground: 'hsl(var(--popover-foreground))' },\n        card: { DEFAULT: 'hsl(var(--card))', foreground: 'hsl(var(--card-foreground))' },\n      },\n      borderRadius: {\n        lg: 'var(--radius)',\n        md: 'calc(var(--radius) - 2px)',\n        sm: 'calc(var(--radius) - 4px)',\n      },\n    },\n  },\n  plugins: [],\n}\n`;
          const needsWrite = !twRaw || !/colors:\s*\{[\s\S]*border:/m.test(twRaw) || !/content:\s*\[/m.test(twRaw);
          if (needsWrite) {
            const pathToWrite = twPath && twPath.endsWith(".cjs") ? twPath : "tailwind.config.cjs";
            await sandbox.files.write(pathToWrite, shadcnTwCjs);
            result.state.data.files[pathToWrite] = shadcnTwCjs;
          }
        } catch (e) {
          console.warn("postprocess: tailwind config ensure failed", e);
        }

        // 2.5) Ensure next.config images allows picsum.photos
        try {
          const jsPath = "next.config.js";
          const mjsPath = "next.config.mjs";
          const jsRaw = await readSafe(jsPath);
          const mjsRaw = await readSafe(mjsPath);

          if (!jsRaw && !mjsRaw) {
            const cfg = `/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  images: { domains: ['picsum.photos'] },\n};\nmodule.exports = nextConfig;\n`;
            await sandbox.files.write(jsPath, cfg);
            result.state.data.files[jsPath] = cfg;
          } else if (jsRaw && !/picsum\.photos/.test(jsRaw)) {
            const patched = `${jsRaw}\n// Ensure picsum.photos domain for next/image\nmodule.exports.images = module.exports.images || {};\nmodule.exports.images.domains = Array.from(new Set([...(module.exports.images.domains || []), 'picsum.photos']));\n`;
            await sandbox.files.write(jsPath, patched);
            result.state.data.files[jsPath] = patched;
          }
        } catch (e) {
          console.warn("postprocess: ensure next.config images failed", e);
        }

        // 3) Ensure globals.css has CSS variables for shadcn
        try {
          const gPath = "app/globals.css";
          const gRaw = await readSafe(gPath);
          const baseCss = `@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer base {\n  :root {\n    --background: 0 0% 100%;\n    --foreground: 222.2 84% 4.9%;\n    --card: 0 0% 100%;\n    --card-foreground: 222.2 84% 4.9%;\n    --popover: 0 0% 100%;\n    --popover-foreground: 222.2 84% 4.9%;\n    --primary: 221.2 83.2% 53.3%;\n    --primary-foreground: 210 40% 98%;\n    --secondary: 210 40% 96.1%;\n    --secondary-foreground: 222.2 47.4% 11.2%;\n    --muted: 210 40% 96.1%;\n    --muted-foreground: 215.4 16.3% 46.9%;\n    --accent: 210 40% 96.1%;\n    --accent-foreground: 222.2 47.4% 11.2%;\n    --destructive: 0 84.2% 60.2%;\n    --destructive-foreground: 210 40% 98%;\n    --border: 214.3 31.8% 91.4%;\n    --input: 214.3 31.8% 91.4%;\n    --ring: 221.2 83.2% 53.3%;\n    --radius: 0.5rem;\n  }\n  .dark {\n    --background: 222.2 84% 4.9%;\n    --foreground: 210 40% 98%;\n    --card: 222.2 84% 4.9%;\n    --card-foreground: 210 40% 98%;\n    --popover: 222.2 84% 4.9%;\n    --popover-foreground: 210 40% 98%;\n    --primary: 217.2 91.2% 59.8%;\n    --primary-foreground: 222.2 47.4% 11.2%;\n    --secondary: 217.2 32.6% 17.5%;\n    --secondary-foreground: 210 40% 98%;\n    --muted: 217.2 32.6% 17.5%;\n    --muted-foreground: 215 20.2% 65.1%;\n    --accent: 217.2 32.6% 17.5%;\n    --accent-foreground: 210 40% 98%;\n    --destructive: 0 62.8% 30.6%;\n    --destructive-foreground: 0 85.7% 97.3%;\n    --border: 217.2 32.6% 17.5%;\n    --input: 217.2 32.6% 17.5%;\n    --ring: 224.3 76.3% 48%;\n  }\n}\n`;
          if (!gRaw || !/:root\s*\{[\s\S]*--background:/m.test(gRaw)) {
            const out = gRaw ? `${baseCss}\n${gRaw}` : baseCss;
            await sandbox.files.write(gPath, out);
            result.state.data.files[gPath] = out;
          }
        } catch (e) {
          console.warn("postprocess: globals.css ensure failed", e);
        }

        // 4) Ensure tsconfig paths for @/*
        try {
          const tsPath = "tsconfig.json";
          const tsRaw = await readSafe(tsPath);
          if (tsRaw) {
            const ts = JSON.parse(tsRaw);
            ts.compilerOptions = ts.compilerOptions || {};
            ts.compilerOptions.baseUrl = ts.compilerOptions.baseUrl || ".";
            ts.compilerOptions.paths = ts.compilerOptions.paths || {};
            if (!ts.compilerOptions.paths["@/*"]) {
              ts.compilerOptions.paths["@/*"] = ["./*"];
            }
            const next = JSON.stringify(ts, null, 2) + "\n";
            if (next !== tsRaw) {
              await sandbox.files.write(tsPath, next);
              result.state.data.files[tsPath] = next;
            }
          }
        } catch (e) {
          console.warn("postprocess: tsconfig ensure failed", e);
        }

        // 5) Ensure lib/utils.ts with cn
        try {
          const utilPath = "lib/utils.ts";
          const utilRaw = await readSafe(utilPath);
          if (!utilRaw) {
            const content = `import { type ClassValue } from 'clsx';\nimport { clsx } from 'clsx';\nimport { twMerge } from 'tailwind-merge';\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n`;
            await sandbox.files.write(utilPath, content);
            result.state.data.files[utilPath] = content;
          }
        } catch (e) {
          console.warn("postprocess: utils.ts ensure failed", e);
        }

        // 6) Stub missing UI components referenced anywhere in the project
        try {
          const importRegex = new RegExp(String.raw`import\s+([^'";]+)\s+from\s+["']@/components/ui/([^"']+)["'];?`, "g");
          const modules = new Map<string, string[]>();
          for (const [path, content] of Object.entries(result.state.data.files)) {
            if (typeof content !== "string") continue;
            if (!/(\.tsx|\.ts|\.jsx|\.js)$/i.test(path)) continue;
            const matches = content.matchAll(importRegex);
            for (const m of matches) {
              const spec = m[1].trim();
              const mod = m[2].trim();
              const names: string[] = [];
              const named = spec.match(/\{([^}]+)\}/);
              if (named) {
                for (const n of named[1].split(",")) names.push(n.trim().split(/\s+as\s+/)[0]);
              }
              const defMatch = spec.replace(named?.[0] || "", "").trim();
              if (defMatch && defMatch !== ",") names.push("default:" + defMatch);
              const prev = modules.get(mod) || [];
              modules.set(mod, prev.concat(names));
            }
          }
          for (const [mod, names] of modules) {
            const target = `components/ui/${mod}.tsx`;
            const exists = await readSafe(target);
            if (!exists) {
              if (mod === "accordion") {
                // Write a real shadcn-style accordion using Radix (no CSS files required)
                const content = `"use client";\n\nimport * as React from "react";\nimport * as AccordionPrimitive from "@radix-ui/react-accordion";\nimport { ChevronDown } from "lucide-react";\nimport { cn } from "@/lib/utils";\n\nconst Accordion = AccordionPrimitive.Root;\n\nconst AccordionItem = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <AccordionPrimitive.Item\n    ref={ref}\n    className={cn("border-b", className)}\n    {...props}\n  />\n));\nAccordionItem.displayName = "AccordionItem";\n\nconst AccordionTrigger = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Header className="flex">\n    <AccordionPrimitive.Trigger\n      ref={ref}\n      className={cn(\n        "flex flex-1 items-center justify-between py-4 text-left font-medium transition-all hover:underline",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200 data-[state=open]:rotate-180" />\n    </AccordionPrimitive.Trigger>\n  </AccordionPrimitive.Header>\n));\nAccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName;\n\nconst AccordionContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Content\n    ref={ref}\n    className={cn(\n      "overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down",\n      className\n    )}\n    {...props}\n  >\n    <div className="pb-4 pt-0">{children}</div>\n  </AccordionPrimitive.Content>\n));\nAccordionContent.displayName = AccordionPrimitive.Content.displayName;\n\nexport { Accordion, AccordionItem, AccordionTrigger, AccordionContent };\n`;
                await sandbox.files.write(target, content);
                result.state.data.files[target] = content;

                // Ensure dependency exists in package.json
                try {
                  const pkgPath = "package.json";
                  const pkgRaw = await readSafe(pkgPath);
                  if (pkgRaw) {
                    const pkg = JSON.parse(pkgRaw);
                    pkg.dependencies = pkg.dependencies || {};
                    if (!pkg.dependencies["@radix-ui/react-accordion"]) {
                      pkg.dependencies["@radix-ui/react-accordion"] = "latest";
                      const nextRaw = JSON.stringify(pkg, null, 2) + "\n";
                      await sandbox.files.write(pkgPath, nextRaw);
                      result.state.data.files[pkgPath] = nextRaw;
                    }
                  }
                } catch (e) {
                  console.warn("postprocess: add @radix-ui/react-accordion failed", e);
                }
              } else {
                // Fallback: lightweight stub
                const exports: string[] = [];
                const defaultName = names.find((n) => n.startsWith("default:"))?.split(":")[1];
                if (defaultName) {
                  exports.push(`const ${defaultName} = (props: any) => <div {...props} />;\nexport default ${defaultName};`);
                }
                const named = names.filter((n) => !n.startsWith("default:"));
                for (const n of named) {
                  if (!n) continue;
                  exports.push(`export const ${n} = (props: any) => <div {...props} />;`);
                }
                const stub = `"use client";\nimport React from 'react';\n${exports.join("\n")}\n`;
                await sandbox.files.write(target, stub);
                result.state.data.files[target] = stub;
              }
            }
          }
        } catch (e) {
          console.warn("postprocess: stub ui components failed", e);
        }

  // 7) Ensure shadcn components.json exists (helps users extend components later)
        try {
          const cfgPath = "components.json";
          const existing = await readSafe(cfgPath);
          if (!existing) {
            // Detect tailwind config file name written earlier
            const twJs = await readSafe("tailwind.config.js");
            const twCjs = await readSafe("tailwind.config.cjs");
            const twFile = twJs ? "tailwind.config.js" : twCjs ? "tailwind.config.cjs" : "tailwind.config.js";
            const cfg = {
              $schema: "https://ui.shadcn.com/schema.json",
              style: "default",
              rsc: true,
              tsx: true,
              tailwind: {
                config: twFile,
                css: "app/globals.css",
                baseColor: "slate",
                cssVariables: true,
                prefix: "",
              },
              aliases: { components: "@/components", utils: "@/lib/utils" },
            } as any;
            const raw = JSON.stringify(cfg, null, 2) + "\n";
            await sandbox.files.write(cfgPath, raw);
            result.state.data.files[cfgPath] = raw;
          }
        } catch (e) {
          console.warn("postprocess: components.json ensure failed", e);
        }

        // 8) Defensive: backgrounds shouldn't block clicks (don't force z-index to avoid hiding effects).
        try {
          const entries = Object.entries(result.state.data.files);
          for (const [path, content] of entries) {
            if (!/\.(tsx|jsx)$/.test(path)) continue;
            if (typeof content !== "string") continue;
            // Add pointer-events-none and select-none to common decorative background wrappers
            let next = content.replace(
              /(className=\"[^\"]*\babsolute\b[^\"]*\binset-0\b[^\"]*)(\")/g,
              (m, p1, p2) =>
                p1.includes("pointer-events-none") ? m : `${p1} pointer-events-none select-none${p2}`
            );
            if (next !== content) {
              await sandbox.files.write(path, next);
              result.state.data.files[path] = next;
            }
          }
        } catch (e) {
          console.warn("postprocess: background safety patch failed", e);
        }

        // 9) Ensure runtime deps for animations exist and are installed in sandbox
        try {
          const entries = Object.entries(result.state.data.files);
          let needsFramer = false;
          let needsSlot = false;
          for (const [path, content] of entries) {
            if (!/\.(tsx|ts|jsx|js)$/.test(path)) continue;
            if (typeof content !== "string") continue;
            if (/from\s+['"]framer-motion['"]/m.test(content)) needsFramer = true;
            if (/from\s+['"]@radix-ui\/react-slot['"]/m.test(content)) needsSlot = true;
          }
          const pkgPath = "package.json";
          const pkgRaw = await readSafe(pkgPath);
          if (pkgRaw) {
            const pkg = JSON.parse(pkgRaw);
            pkg.dependencies = pkg.dependencies || {};
            let changed = false;
            if (needsFramer && !pkg.dependencies["framer-motion"]) {
              pkg.dependencies["framer-motion"] = "latest";
              changed = true;
            }
            if (needsSlot && !pkg.dependencies["@radix-ui/react-slot"]) {
              pkg.dependencies["@radix-ui/react-slot"] = "latest";
              changed = true;
            }
            if (changed) {
              const nextRaw = JSON.stringify(pkg, null, 2) + "\n";
              await sandbox.files.write(pkgPath, nextRaw);
              result.state.data.files[pkgPath] = nextRaw;
              // Install deps in sandbox so preview can run animations
              try {
                await sandbox.commands.run("npm i --no-audit --no-fund");
              } catch (e) {
                console.warn("sandbox npm install failed", e);
              }
            }
          }
        } catch (e) {
          console.warn("postprocess: ensure animation deps failed", e);
        }
      });
    }

    // Reconcile: ensure all in-memory files exist in the sandbox before composing the page
    await step.run("reconcile-files-to-sandbox", async () => {
      try {
        const sandbox = await getSandbox(sandboxId);
        const files = (result.state.data.files || {}) as Record<string, string>;
        for (const [p, c] of Object.entries(files)) {
          try {
            await sandbox.files.read(p);
          } catch {
            await sandbox.files.write(p, String(c ?? ""));
          }
        }
      } catch (e) {
        console.warn("reconcile-files-to-sandbox (create) failed", e);
      }
    });

    // Ensure a root page exists or repair if default template before exposing URL
    await step.run("ensure-root-page", async () => {
      try {
        const files = (result.state.data.files || {}) as Record<string, string>;
        const sandbox = await getSandbox(sandboxId);
        const hasSrc = Object.keys(files).some((p) => p.startsWith("src/"));
        const pagePath = hasSrc ? "src/app/page.tsx" : "app/page.tsx";
        let pageRaw = "";
        try { pageRaw = await sandbox.files.read(pagePath); } catch {}
        const isDefault = !!pageRaw && DEFAULT_NEXT_TEMPLATE_RE.test(pageRaw);
        const missing = !pageRaw;
        if (!missing && !isDefault) return;

        // Build imports + body from existing app sections that expose a named export matching file name
        const candidates = Object.entries(files)
          .filter(([p]) => /^(src\/)?app\/.+\.tsx$/i.test(p) && !/\b(page|layout)\.tsx$/i.test(p))
          .map(([p, content]) => ({ p, content: String(content || "") }));

        const pick = (names: string[]) => candidates.find((c) => names.some((n) => new RegExp(`(^|\/)${n}\.tsx$`, "i").test(c.p)));
        const ordered: { name: string; rel: string; content: string }[] = [];
        const pushIf = (base: string) => {
          const hit = candidates.find((c) => new RegExp(`(^|\/)${base}\.tsx$`, "i").test(c.p));
          if (!hit) return;
          const name = base.replace(/\.tsx$/i, "");
          if (new RegExp(`export\s+(function|const|class)\s+${name}\b`).test(hit.content)) {
            const rel = `./${name}`;
            ordered.push({ name, rel, content: hit.content });
          }
        };
        // Prefer common sections first
        pushIf("Navbar");
        pushIf("HeroBanner");
        // Add a few more common names if present
        ["Header","Hero","CallToAction","Features","Pricing","Testimonials","Clients","Gallery","VideoSection","Contact","Footer"].forEach(pushIf);
        // If nothing matched from in-memory files, try reading common sections directly from sandbox
        if (ordered.length === 0) {
          const common = ["Navbar","HeroBanner","Header","Hero","CallToAction","Features","Pricing","Testimonials","Clients","Gallery","VideoSection","Contact","Footer"];
          for (const base of common) {
            const p = `${hasSrc ? "src/" : ""}app/${base}.tsx`;
            try {
              const src = await sandbox.files.read(p);
              if (src && new RegExp(`export\\s+(function|const|class)\\s+${base}\\b`).test(src)) {
                ordered.push({ name: base, rel: `./${base}`, content: src });
              }
            } catch {}
          }
        }

        // Fallback: if nothing matched, create minimal page
        const imports = ordered.map((o) => `import { ${o.name} } from '${o.rel}';`).join("\n");
        const body = ordered.map((o) => `      <${o.name} />`).join("\n");
        const composed = `"use client";\n${imports ? imports + "\n\n" : ""}export default function Page(){\n  return (\n    <main className=\"min-h-screen w-full flex flex-col\">\n${body || "      <div />"}\n    </main>\n  );\n}\n`;
        await sandbox.files.write(pagePath, composed);
        files[pagePath] = composed;
        (result.state.data.files as any) = files;
      } catch (e) {
        console.warn("ensure-root-page (create) failed", e);
      }
    });

    // Snapshot essential files (like app/src app page) after ensuring final page content
    await step.run("snapshot-essential-files", async () => {
      try {
        const sandbox = await getSandbox(sandboxId);
        const candidates = ["app/page.tsx", "src/app/page.tsx"];
        for (const p of candidates) {
          try {
            const src = await sandbox.files.read(p);
            if (src && typeof src === "string") {
              (result.state.data.files as any)[p] = src;
            }
          } catch {}
        }
      } catch (e) {
        console.warn("snapshot-essential-files (create) failed", e);
      }
    });

    const sandboxUrl = await step.run("get-sandbox-url", async () => {
      const sandbox = await getSandbox(sandboxId);
      const host = sandbox.getHost(3000);
      console.log("üåê Sandbox URL:", `https://${host}`);
      return `https://${host}`;
    });

  await step.run("save-result", async () => {
      if (isError) {
        const errorMessage = await prisma.message.create({
          data: {
            projectId: event.data.projectId,
            content: "Alguam coisa deu errado. Tente novamente.",
            role: "ASSISTANT",
            type: "ERROR",
          },
        });
        console.log("‚ùå Saved error result:", errorMessage.id);
        return errorMessage;
      }

  const successMessage = await prisma.message.create({
        data: {
          projectId: event.data.projectId,
          content: parseAgentOutput(responseOutput),
          role: "ASSISTANT",
          type: "RESULT",
          fragment: {
            create: {
              sandboxUrl,
              title: parseAgentOutput(fragmentTitleOutput),
              files: result.state.data.files,
            },
          },
        },
      });
      
      // Update project name with the generated title if available
      const generatedTitle = parseAgentOutput(fragmentTitleOutput);
      if (generatedTitle && generatedTitle !== "Landing Page") {
        await prisma.project.update({
          where: { id: event.data.projectId },
          data: { name: generatedTitle }
        });
      }
      
      console.log("‚úÖ Saved success result:", successMessage.id);
      return successMessage;
    });
    console.log("üéâ Code-agent function completed");
    return {
      url: sandboxUrl,
      title: "Fragment",
      files: result.state.data.files,
      summary: result.state.data.summary,
    };
  }
);

export const codeAgentEditFunction = inngest.createFunction(
  { id: "code-agent-edit" },
  { event: "code-agent/edit" },
  async ({ event, step }) => {
    console.log("üîß Starting code-agent-edit");
    const sandboxId = await getOrCreateSandboxId(step);

    // Load last fragment files for this project
    const existing = await step.run("load-existing-files", async () => {
      const last = await prisma.message.findFirst({
        where: {
          projectId: (event.data as any).projectId,
          role: "ASSISTANT",
          type: "RESULT",
          fragment: { isNot: null },
        },
        include: { fragment: true },
        orderBy: { createdAt: "desc" },
      });
      const files = ((last as any)?.fragment?.files as FileCollection | undefined) || {};
      // Harden: if previous fragment missed app/src page.tsx, synthesize one from known sections
      try {
        const hasSrc = Object.keys(files).some((p) => p.startsWith("src/"));
        const pagePath = hasSrc ? "src/app/page.tsx" : "app/page.tsx";
        if (!files[pagePath]) {
          const candidates = Object.entries(files)
            .filter(([p]) => /^(src\/)?app\/.+\.tsx$/i.test(p) && !/\b(page|layout)\.tsx$/i.test(p))
            .map(([p, content]) => ({ p, content: String(content || "") }));
          const ordered: { name: string; rel: string; content: string }[] = [];
          const pushIf = (base: string) => {
            const hit = candidates.find((c) => new RegExp(`(^|\/)${base}\.tsx$`, "i").test(c.p));
            if (!hit) return;
            const name = base.replace(/\.tsx$/i, "");
            if (new RegExp(`export\\s+(function|const|class)\\s+${name}\\b`).test(hit.content)) {
              const rel = `./${name}`;
              ordered.push({ name, rel, content: hit.content });
            }
          };
          [
            "Navbar",
            "HeroBanner",
            "Header",
            "Hero",
            "CallToAction",
            "Features",
            "Pricing",
            "Testimonials",
            "Clients",
            "Gallery",
            "VideoSection",
            "Contact",
            "Footer",
          ].forEach(pushIf);
          const imports = ordered.map((o) => `import { ${o.name} } from '${o.rel}';`).join("\n");
          const body = ordered.map((o) => `      <${o.name} />`).join("\n");
          const composed = `"use client";\n${imports ? imports + "\n\n" : ""}export default function Page(){\n  return (\n    <main className=\"min-h-screen w-full flex flex-col\">\n${body || "      <div />"}\n    </main>\n  );\n}\n`;
          files[pagePath] = composed;
        }
      } catch {}
      return files;
    });

    // Hydrate sandbox with existing files
    await step.run("hydrate-sandbox", async () => {
      const sandbox = await getSandbox(sandboxId);
      for (const [path, content] of Object.entries(existing)) {
        try {
          await sandbox.files.write(path, content as string);
        } catch (e) {
          console.warn("hydrate write failed", path, e);
        }
      }
    });

    const previousMessages: Message[] = [];
    const state = createState<AgentState>(
      {
        summary: "",
        files: { ...existing },
        allowedPaths: [],
      },
      { messages: previousMessages }
    );

    const hasSrc = Object.keys(existing).some((p) => p.startsWith("src/"));
    const userText = String((event.data as any).value || "");
    // Hint de arquivo do bloco de c√≥digo: ```tsx nome
    const codeFencePathMatch = userText.match(/```(?:tsx|ts|jsx|js)\s+([^\s`]+)/i);
    const codeFencePath = codeFencePathMatch?.[1];
    // Imports citados
    const importPaths = Array.from(userText.matchAll(/from\s+["'`](.*?)["'`]/g)).map((m) => m[1]);
    const hintedPathsSet = new Set<string>();
    if (codeFencePath) hintedPathsSet.add(codeFencePath);
    importPaths.forEach((p) => hintedPathsSet.add(p));
    const hintedAllowed = Array.from(hintedPathsSet)
      .map((p) => normalizeSandboxPath(p, hasSrc))
      .filter((path): path is string => path !== null);

    // Impact analyzer to select minimal set of files
    const impactAnalyzer = createAgent<AgentState>({
      name: "impact-analyzer",
      description: "Select minimal impacted files for the change request",
      system:
        "You are an impact analyzer. Given a change request and a file map, return a compact JSON array of file paths to modify. Rules:\n- Select the smallest set of files that must change to implement the request.\n- Do not include files that do not need edits.\n- Output ONLY a JSON array of strings (no markdown, no commentary).",
      model: azureOpenAICompat({
        endpoint: process.env.AZURE_OPENAI_ENDPOINT!,
        apiKey: process.env.AZURE_OPENAI_5_API_KEY || process.env.AZURE_OPENAI_API_KEY!,
        deployment: process.env.AZURE_OPENAI_5_DEPLOYMENT || process.env.AZURE_OPENAI_DEPLOYMENT!,
        apiVersion: process.env.AZURE_OPENAI_5_API_VERSION || process.env.AZURE_OPENAI_API_VERSION!,
        defaultParameters: { temperature: 0.1 },
      }),
    });

    const fileIndex = Object.keys(existing).slice(0, 2000);
    const analyzerInput = JSON.stringify({
      request: (event.data as any).value,
      files: fileIndex,
    });
    const { output: impactOutput } = await impactAnalyzer.run(analyzerInput);
    let allowedPaths: string[] = [];
    try {
      const text = impactOutput
        .filter((m: any) => m.type === "text")
        .map((m: any) => (m as any).content)
        .join("");
      const parsed = JSON.parse(Array.isArray(text) ? (text as any).join("") : text);
      if (Array.isArray(parsed)) {
        allowedPaths = parsed.filter((p) => typeof p === "string");
      }
    } catch (e) {
      console.warn("impact parse failed, using heuristic fallback", e);
    }

    if (allowedPaths.length === 0) {
      allowedPaths = fileIndex.filter((p) => /\.(tsx|ts|jsx|js)$/.test(p)).slice(0, 5);
    }
    // Une com os caminhos sugeridos pelo usu√°rio
    const union = new Set<string>([...allowedPaths, ...hintedAllowed]);
    // Normalize todos os caminhos permitidos de acordo com a estrutura (src/ ou n√£o)
    const normalizedAllowed = new Set<string>();
    for (const p of Array.from(union)) {
      try {
        const normalized = normalizeSandboxPath(p, hasSrc);
        if (normalized) {
          normalizedAllowed.add(normalized);
        }
      } catch {
        // ignora caminhos inv√°lidos
      }
    }
  // Garante que a p√°gina principal sempre pode ser editada (single-page landing)
  normalizedAllowed.add(hasSrc ? "src/app/page.tsx" : "app/page.tsx");
  // Permite criar/editar se√ß√µes na pasta app/
  normalizedAllowed.add(hasSrc ? "src/app/*" : "app/*");
    const finalAllowed = Array.from(normalizedAllowed);
    state.data.allowedPaths = finalAllowed;

    const enrichedInstructionForSteps = [
      (event.data as any).value,
      `Only edit: ${(state.data.allowedPaths || []).join(", ")}`,
    ]
      .filter(Boolean)
      .join("\n\n");

    const taskStepsGenerator = createTaskStepsAgent();

    const { output: taskStepsOutput } = await taskStepsGenerator.run(
      enrichedInstructionForSteps
    );
    logAssistantTexts("task-steps-generator", taskStepsOutput);
    console.log("üìã Task steps generated for edit");

    await step.run("save-steps-for-edit", async () => {
      const stepsMessage = await prisma.message.create({
        data: {
          projectId: (event.data as any).projectId,
          content: parseAgentOutput(taskStepsOutput),
          role: "ASSISTANT",
          type: "STEPS",
        },
      });
      console.log("üíæ Edit steps saved:", stepsMessage.id);
      return stepsMessage;
    });

    // Editor agent uses dedicated EDIT_PROMPT to enforce non-destructive edits
    const editorAgent = createAgent<AgentState>({
      name: "code-editor",
      description: "Edit only the allowed files for the requested change",
  system: `${EDIT_PROMPT}\n\nAllowed files:\n${(state.data.allowedPaths || []).map((p) => `- ${p}`).join("\n")}`,
      model: azureOpenAICompat({
        endpoint: process.env.AZURE_OPENAI_ENDPOINT!,
        apiKey: process.env.AZURE_OPENAI_5_API_KEY || process.env.AZURE_OPENAI_API_KEY!,
        deployment: process.env.AZURE_OPENAI_5_DEPLOYMENT || process.env.AZURE_OPENAI_DEPLOYMENT!,
        apiVersion: process.env.AZURE_OPENAI_5_API_VERSION || process.env.AZURE_OPENAI_API_VERSION!,
        defaultParameters: { temperature: 0.1 },
      }),
      tools: [
        // Reuse tools from main agent by redefining here
        createTool({
          name: "terminal",
          description: "Use the terminal to run commands",
          parameters: z.object({ command: z.string() }),
          handler: async ({ command }, { step }) => {
            return await step?.run("terminal", async () => {
              const buffers = { stdout: "", stderr: "" };
              try {
                const sandbox = await getSandbox(sandboxId);
                const result = await sandbox.commands.run(command, {
                  onStdout: (d: string) => {
                    buffers.stdout += d;
                  },
                  onStderr: (d: string) => {
                    buffers.stderr += d;
                  },
                });
                return result.stdout;
              } catch (error) {
                return `command failed: ${error}\nstdOut: ${buffers.stdout}\nstdError: ${buffers.stderr}`;
              }
            });
          },
        }),
        createTool({
          name: "createOrUpdateFiles",
          description: "Create or update files in the sandbox",
          parameters: z.object({
            files: z.array(z.object({ path: z.string(), content: z.string() })),
          }),
          handler: async ({ files }, { step, network }) => {
            const newFiles = await step?.run("createOrUpdateFiles", async () => {
              try {
                const updatedFiles = network.state.data.files || {};
                const sandbox = await getSandbox(sandboxId);
                const hasSrc = Object.keys(updatedFiles).some((p) => p.startsWith("src/"));
                const guard = new Set<string>((network.state.data.allowedPaths || []) as string[]);
                for (const file of files) {
                  let normalized = normalizeSandboxPath(file.path, hasSrc);
                  if (!normalized) {
                    console.warn(`üö´ Invalid path: ${file.path}`);
                    continue;
                  }
                  
                  if (guard.size > 0 && !guard.has(normalized) && 
                      !Array.from(guard).some(g => 
                        (g.endsWith("/*") && normalized.startsWith(g.slice(0, -2))) ||
                        (g.endsWith("/") && normalized.startsWith(g))
                      )) {
                    console.warn(`[edit-guard] blocked write to ${normalized}`);
                    continue;
                  }
                  if (/\/demo\.(tsx|jsx|ts|js)$/i.test(normalized)) {
                    console.warn(`[policy] demo files are not allowed: ${normalized}`);
                    continue;
                  }
                  // Light guard: prevent removing critical sections inadvertently
                  if (/^app\/page\.(tsx|jsx|ts|js)$/i.test(normalized)) {
                    const prev = typeof updatedFiles[normalized] === "string"
                      ? (updatedFiles[normalized] as string)
                      : await (async () => { try { return await sandbox.files.read(normalized); } catch { return ""; } })();
                    if (prev) {
                      // Simple check for critical sections
                      const hadMain = /<main\b/i.test(prev);
                      const hasMain = /<main\b/i.test(file.content);
                      if (hadMain && !hasMain) return `Blocked edit to ${normalized}: main tag removed`;
                      const hadHeader = /<\s*(Navbar|header)\b/i.test(prev);
                      const hasHeader = /<\s*(Navbar|header)\b/i.test(file.content);
                      if (hadHeader && !hasHeader) return `Blocked edit to ${normalized}: header/navbar removed`;
                      const hadFooter = /<\s*(Footer|footer)\b/i.test(prev);
                      const hasFooter = /<\s*(Footer|footer)\b/i.test(file.content);
                      if (hadFooter && !hasFooter) return `Blocked edit to ${normalized}: footer removed`;
                    }
                  }
                  const finalContent = normalizeAppFileContent(normalized, file.content);
                  await sandbox.files.write(normalized, finalContent);
                  updatedFiles[normalized] = finalContent;
                }
                return updatedFiles;
              } catch (error) {
                return "Error: " + error;
              }
            });
            if (typeof newFiles === "object") {
              const prev = (network.state.data.files || {}) as Record<string, string>;
              (network as any).state.data.files = { ...prev, ...(newFiles as any) } as any;
            }
          },
        }),
        createTool({
          name: "safeUpdatePage",
          description: "Non-destructive update for app/page.*. Inserts a component into <main> and ensures import; preserves the rest of the file.",
          parameters: z.object({
            filePath: z.string().default("app/page.tsx"),
            importLine: z.string(),
            jsx: z.string(),
            position: z.enum(["prepend", "append"]).default("append"),
          }),
          handler: async ({ filePath, importLine, jsx, position }, { step, network }) => {
            return await step?.run("safeUpdatePage", async () => {
              const sandbox = await getSandbox(sandboxId);
              const filesState = (network.state.data.files || {}) as Record<string, string>;
              const hasSrc = Object.keys(filesState).some((p) => p.startsWith("src/")) ||
                (await (async () => { try { await sandbox.files.read("src/app/page.tsx"); return true; } catch { return false; } })());
              const path = normalizeSandboxPath(filePath, hasSrc);
              if (!path) return `Invalid path: ${filePath}`;
              const guard = new Set<string>((network.state.data.allowedPaths || []) as string[]);
              if (guard.size > 0 && !guard.has(path) && 
                  !Array.from(guard).some(g => 
                    (g.endsWith("/*") && path.startsWith(g.slice(0, -2))) ||
                    (g.endsWith("/") && path.startsWith(g))
                  )) return `Blocked: ${path} not in allowedPaths.`;
              let prev = "";
              try { prev = await sandbox.files.read(path); } catch {}
              if (!prev) {
                prev = `"use client";\n\nexport default function Page(){\n  return (<main className=\"min-h-screen w-full\">{\"\"}</main>);\n}\n`;
              }
              // Simplified approach for safe page update
              let next = prev;
              if (importLine?.trim() && !prev.includes(importLine.trim())) {
                const lines = prev.split("\n");
                let insertIdx = 0;
                if (/^\s*['"]use client['"]\s*;?/.test(lines[0] || "")) insertIdx = 1;
                for (let i = insertIdx; i < lines.length; i++) {
                  if (/^\s*import\s+/.test(lines[i])) insertIdx = i + 1;
                  else if (lines[i].trim() && !/^\s*(\/\*|\/\/)/.test(lines[i])) break;
                }
                lines.splice(insertIdx, 0, importLine.trim());
                next = lines.join("\n");
              }
              // Insert JSX into main tag
              const mainMatch = next.match(/<main\b[^>]*>([\s\S]*?)<\/main>/i);
              if (mainMatch) {
                const mainContent = mainMatch[1];
                const newMainContent = position === "prepend" 
                  ? `\n      ${jsx}\n${mainContent}` 
                  : `${mainContent}\n      ${jsx}\n`;
                next = next.replace(/<main\b[^>]*>[\s\S]*?<\/main>/i, 
                  mainMatch[0].replace(mainContent, newMainContent));
              } else {
                next = next + `\n${jsx}\n`;
              }
              await sandbox.files.write(path, next);
              network.state.data.files[path] = next;
              return `Updated ${path} with safe merge`;
            });
          },
        }),
        createTool({
          name: "readFiles",
          description: "Read files from the sandbox",
          parameters: z.object({ files: z.array(z.string()) }),
          handler: async ({ files }, { step }) => {
            return await step?.run("readFiles", async () => {
              try {
                const sandbox = await getSandbox(sandboxId);
                const contents: any[] = [];
                // Usa presen√ßa de src/ no sandbox a partir do estado do editor (poderia estar vazio, cair√° em false)
                // N√£o temos network aqui, ent√£o fazemos tentativa com heur√≠stica b√°sica: se caminho come√ßa com '@/'
                const hasSrcHeuristic = files.some((p) => p.startsWith("@/"));
                for (const f of files) {
                  const p = normalizeSandboxPath(f, hasSrcHeuristic);
                  if (!p) {
                    contents.push({ path: f, content: null, error: "Invalid path" });
                    continue;
                  }
                  try {
                    const content = await sandbox.files.read(p);
                    contents.push({ path: p, content });
                  } catch (e: any) {
                    const msg = String(e?.message || e);
                    if (/NotFound/i.test(msg)) {
                      console.warn(`[readFiles] not found: ${p}`);
                      contents.push({ path: p, content: null });
                      continue;
                    }
                    throw e;
                  }
                }
                return JSON.stringify(contents);
              } catch (error) {
                return "Error: " + error;
              }
            });
          },
        }),
      ],
      lifecycle: {
        onResponse: async ({ result, network }) => {
          logAssistantTexts("code-editor", result.output);
          const lastAssistantTextMessageText = lastAssistantTextMessageContent(result);
          if (lastAssistantTextMessageText && network) {
            if (lastAssistantTextMessageText.includes("<task_summary>")) {
              network.state.data.summary = lastAssistantTextMessageText;
            }
          }
          return result;
        },
      },
    });

    const editorNetwork = createNetwork<AgentState>({
      name: "coding-editor-network",
      agents: [editorAgent],
      maxIter: 12,
      defaultState: state,
      router: async ({ network }) => {
        const summary = network.state.data.summary;
        if (summary) return;
        return editorAgent;
      },
    });

    const enrichedInstruction = [
      (event.data as any).value,
      `Only edit: ${(state.data.allowedPaths || []).join(", ")}`,
    ]
      .filter(Boolean)
      .join("\n\n");

    const result = await editorNetwork.run(enrichedInstruction, { state });

    const fragmentTitleGenerator = createFragmentTitleAgent();
    const responseGenerator = createResponseAgent();

    const { output: fragmentTitleOutput } = await fragmentTitleGenerator.run(
      result.state.data.summary
    );
    const { output: responseOutput } = await responseGenerator.run(
      result.state.data.summary
    );

    const isError =
      !result.state.data.summary ||
      Object.keys(result.state.data.files || {}).length === 0;

    // Reconcile: ensure all in-memory files exist in the sandbox before composing the page
    await step.run("reconcile-files-to-sandbox", async () => {
      try {
        const sandbox = await getSandbox(sandboxId);
        const files = (result.state.data.files || {}) as Record<string, string>;
        for (const [p, c] of Object.entries(files)) {
          try {
            await sandbox.files.read(p);
          } catch {
            await sandbox.files.write(p, String(c ?? ""));
          }
        }
      } catch (e) {
        console.warn("reconcile-files-to-sandbox (edit) failed", e);
      }
    });

    // Ensure a root page exists or repair if default template before exposing URL
    await step.run("ensure-root-page", async () => {
      try {
        const files = (result.state.data.files || {}) as Record<string, string>;
        const sandbox = await getSandbox(sandboxId);
        const hasSrc = Object.keys(files).some((p) => p.startsWith("src/"));
        const pagePath = hasSrc ? "src/app/page.tsx" : "app/page.tsx";
        let pageRaw = "";
        try { pageRaw = await sandbox.files.read(pagePath); } catch {}
        const isDefault = !!pageRaw && DEFAULT_NEXT_TEMPLATE_RE.test(pageRaw);
        const missing = !pageRaw;
        if (!missing && !isDefault) return;

        const candidates = Object.entries(files)
          .filter(([p]) => /^(src\/)?app\/.+\.tsx$/i.test(p) && !/\b(page|layout)\.tsx$/i.test(p))
          .map(([p, content]) => ({ p, content: String(content || "") }));

        const ordered: { name: string; rel: string; content: string }[] = [];
        const pushIf = (base: string) => {
          const hit = candidates.find((c) => new RegExp(`(^|\/)${base}\.tsx$`, "i").test(c.p));
          if (!hit) return;
          const name = base.replace(/\.tsx$/i, "");
          if (new RegExp(`export\s+(function|const|class)\s+${name}\b`).test(hit.content)) {
            const rel = `./${name}`;
            ordered.push({ name, rel, content: hit.content });
          }
        };
        ["Navbar","HeroBanner","Header","Hero","CallToAction","Features","Pricing","Testimonials","Clients","Gallery","VideoSection","Contact","Footer"].forEach(pushIf);
        if (ordered.length === 0) {
          const common = ["Navbar","HeroBanner","Header","Hero","CallToAction","Features","Pricing","Testimonials","Clients","Gallery","VideoSection","Contact","Footer"];
          for (const base of common) {
            const p = `${hasSrc ? "src/" : ""}app/${base}.tsx`;
            try {
              const src = await sandbox.files.read(p);
              if (src && new RegExp(`export\\s+(function|const|class)\\s+${base}\\b`).test(src)) {
                ordered.push({ name: base, rel: `./${base}`, content: src });
              }
            } catch {}
          }
        }
        const imports = ordered.map((o) => `import { ${o.name} } from '${o.rel}';`).join("\n");
        const body = ordered.map((o) => `      <${o.name} />`).join("\n");
        const composed = `"use client";\n${imports ? imports + "\n\n" : ""}export default function Page(){\n  return (\n    <main className=\"min-h-screen w-full flex flex-col\">\n${body || "      <div />"}\n    </main>\n  );\n}\n`;
        await sandbox.files.write(pagePath, composed);
        files[pagePath] = composed;
        (result.state.data.files as any) = files;
      } catch (e) {
        console.warn("ensure-root-page (edit) failed", e);
      }
    });

    // Snapshot essential files (like app/src app page) after ensuring final page content
    await step.run("snapshot-essential-files", async () => {
      try {
        const sandbox = await getSandbox(sandboxId);
        const candidates = ["app/page.tsx", "src/app/page.tsx"];
        for (const p of candidates) {
          try {
            const src = await sandbox.files.read(p);
            if (src && typeof src === "string") {
              (result.state.data.files as any)[p] = src;
            }
          } catch {}
        }
      } catch (e) {
        console.warn("snapshot-essential-files (edit) failed", e);
      }
    });

    const sandboxUrl = await step.run("get-sandbox-url", async () => {
      const sandbox = await getSandbox(sandboxId);
      const host = sandbox.getHost(3000);
      return `https://${host}`;
    });

    await step.run("save-result", async () => {
      if (isError) {
        await prisma.message.create({
          data: {
            projectId: (event.data as any).projectId,
            content: "Alguma coisa deu errado, tente novamente! ",
            role: "ASSISTANT",
            type: "ERROR",
          },
        });
        return;
      }

      await prisma.message.create({
        data: {
          projectId: (event.data as any).projectId,
          content: parseAgentOutput(responseOutput),
          role: "ASSISTANT",
          type: "RESULT",
          fragment: {
            create: {
              sandboxUrl,
              title: parseAgentOutput(fragmentTitleOutput),
              files: result.state.data.files,
            },
          },
        },
      });
      
      // Update project name with the generated title if available (edit flow)
      const generatedTitle = parseAgentOutput(fragmentTitleOutput);
      if (generatedTitle && generatedTitle !== "Landing Page") {
        await prisma.project.update({
          where: { id: (event.data as any).projectId },
          data: { name: generatedTitle }
        });
      }
    });

    return {
      url: sandboxUrl,
      title: "Fragment",
      files: result.state.data.files,
      summary: result.state.data.summary,
    };
  }
);
