import { Sandbox } from "@e2b/code-interpreter";
import {
  createAgent,
  createNetwork,
  createState,
  createTool,
  type Message,
  type Tool,
} from "@inngest/agent-kit";
import { z } from "zod";

import prisma from "@/lib/prisma";
import { inngest } from "@/inngest/client";
import { FileCollection } from "@/types";
import { EDIT_PROMPT, FRAGMENT_TITLE_PROMPT, PROMPT, RESPONSE_PROMPT, TASK_STEPS_PROMPT } from "@/prompt";

import { SANDBOX_TIMEOUT_IN_MS } from "@/constants";
import { getSandbox, parseAgentOutput, lastAssistantTextMessageContent } from "@/inngest/utils";

const DEFAULT_NEXT_TEMPLATE_RE = /Learn\s+Next\.js|By\s+vercel|next\.svg|create-next-app|Generated by create next app/i;

function logAssistantTexts(label: string, messages: any) {
  try {
    const arr = Array.isArray(messages) ? messages : [];
    const texts = arr
      .filter((m) => m?.role === "assistant")
      .map((m) => (typeof m?.content === "string" ? m.content : (m?.content || []).map((c: any) => c?.text).join("")))
      .slice(-3);
    if (texts.length) console.log(`[${label}]`, ...texts);
  } catch {}
}

type AzureCompatOptions = {
  endpoint: string;
  apiKey: string;
  deployment: string;
  apiVersion: string;
  defaultParameters?: Record<string, any>;
};

function azureOpenAICompat(opts: AzureCompatOptions) {
  const base = opts.endpoint.replace(/\/+$/, "");
  const url = `${base}/openai/deployments/${opts.deployment}/chat/completions?api-version=${opts.apiVersion}`;
  return {
    format: "openai-chat",
    options: {
      model: opts.deployment,
      defaultParameters: opts.defaultParameters ?? {},
    },
    url,
    headers: {
      "api-key": opts.apiKey,
    },
    authKey: opts.apiKey,
    onCall: (_model: any, body: any) => {
      if (body && typeof body === "object" && "model" in body) {
        delete (body as any).model;
      }
    },
  } as any;
}

type AgentState = {
  summary: string;
  files: Record<string, string>;
  allowedPaths?: string[];
};

// ===== Shared helpers to reduce duplication across flows =====
async function getOrCreateSandboxId(step: any) {
  return await step.run("get-sandbox-id", async () => {
    console.log("Running get-sandbox-id");
    const template =
      process.env.E2B_TEMPLATE_ID ||
      process.env.E2B_TEMPLATE_NAME ||
      "lovable-clone-nextjs-sg-0206";
    console.log("Creating E2B sandbox using template:", template);
    try {
      const sandbox = await Sandbox.create(template);
      await sandbox.setTimeout(SANDBOX_TIMEOUT_IN_MS);
      console.log("Completed get-sandbox-id", sandbox.sandboxId);
      return sandbox.sandboxId;
    } catch (err: any) {
      console.error("Failed to create E2B sandbox. Check E2B_API_KEY access and template ownership.", { message: err?.message });
      throw err;
    }
  });
}

function createTaskStepsAgent() {
  return createAgent({
    name: "task-steps-generator",
    description: "A task steps generator",
    system: TASK_STEPS_PROMPT,
    model: azureOpenAICompat({
      endpoint: process.env.AZURE_OPENAI_ENDPOINT!,
      apiKey: process.env.AZURE_OPENAI_API_KEY!,
      deployment: process.env.AZURE_OPENAI_4_1_DEPLOYMENT!,
      apiVersion: process.env.AZURE_OPENAI_4_1_API_VERSION!,
      defaultParameters: { temperature: 0.1 },
    }),
  });
}

function createFragmentTitleAgent() {
  return createAgent({
    name: "fragment-title-generator",
    description: "A fragment title generator",
    system: FRAGMENT_TITLE_PROMPT,
    model: azureOpenAICompat({
      endpoint: process.env.AZURE_OPENAI_ENDPOINT!,
      apiKey: process.env.AZURE_OPENAI_5_API_KEY || process.env.AZURE_OPENAI_API_KEY!,
      deployment: process.env.AZURE_OPENAI_5_DEPLOYMENT || process.env.AZURE_OPENAI_DEPLOYMENT!,
      apiVersion: process.env.AZURE_OPENAI_5_API_VERSION || process.env.AZURE_OPENAI_API_VERSION!,
      defaultParameters: { temperature: 0.1 },
    }),
  });
}

function createResponseAgent() {
  return createAgent({
    name: "response-generator",
    description: "Generates the user-facing summary message",
    system: RESPONSE_PROMPT,
    model: azureOpenAICompat({
      endpoint: process.env.AZURE_OPENAI_ENDPOINT!,
      apiKey: process.env.AZURE_OPENAI_API_KEY!,
      deployment: process.env.AZURE_OPENAI_4_1_DEPLOYMENT!,
      apiVersion: process.env.AZURE_OPENAI_4_1_API_VERSION!,
      defaultParameters: { temperature: 0.1 },
    }),
  });
}

function createFragmentTitleAgentDefault() {
  return createAgent({
    name: "fragment-title-generator",
    description: "A fragment title generator",
    system: FRAGMENT_TITLE_PROMPT,
    model: azureOpenAICompat({
      endpoint: process.env.AZURE_OPENAI_ENDPOINT!,
      apiKey: process.env.AZURE_OPENAI_API_KEY!,
      deployment: process.env.AZURE_OPENAI_4_1_DEPLOYMENT!,
      apiVersion: process.env.AZURE_OPENAI_4_1_API_VERSION!,
      defaultParameters: { temperature: 0.1 },
    }),
  });
}

function createResponseAgentDefault() {
  return createAgent({
    name: "response-generator",
    description: "A response generator",
    system: RESPONSE_PROMPT,
    model: azureOpenAICompat({
      endpoint: process.env.AZURE_OPENAI_ENDPOINT!,
      apiKey: process.env.AZURE_OPENAI_API_KEY!,
      deployment: process.env.AZURE_OPENAI_DEPLOYMENT!,
      apiVersion: process.env.AZURE_OPENAI_API_VERSION!,
      defaultParameters: { temperature: 0.1 },
    }),
  });
}

async function ensureMetadataStep(step: any, result: any, sandboxId: string, title: string, description: string) {
  await step.run("ensure-metadata", async () => {
    try {
      if (!result?.state?.data) return;
      const files = (result.state.data.files || {}) as Record<string, string>;
      const sandbox = await getSandbox(sandboxId);

      const candidates = [
        "src/app/layout.tsx","src/app/layout.jsx","src/app/layout.ts","src/app/layout.js",
        "app/layout.tsx","app/layout.jsx","app/layout.ts","app/layout.js",
      ];
      let layoutPath = Object.keys(files).find((p) => /^(src\/)?app\/layout\.(tsx|jsx|ts|js)$/i.test(p));
      let raw = layoutPath ? String(files[layoutPath] || "") : "";
      if (!layoutPath || !raw) {
        for (const p of candidates) {
          try {
            const r = await sandbox.files.read(p);
            if (r && typeof r === "string") { layoutPath = p; raw = r; break; }
          } catch {}
        }
      }
      if (!layoutPath) layoutPath = "app/layout.tsx";

      const next = upsertMetadataInLayout(raw, title, description);
      if (next !== raw) {
        await sandbox.files.write(layoutPath, next);
        (result.state.data.files as any)[layoutPath] = next;
      }
    } catch (e) {
      console.warn("ensure-metadata failed", e);
    }
  });
}

// Normaliza caminhos sugeridos pelo modelo/usuário para dentro do sandbox
function normalizeSandboxPath(p: string, hasSrc: boolean): string {
  let s = (p || "").trim().replace(/\\/g, "/");
  // Remove absolutos tipo "/home/user/..." ou barra raiz
  s = s.replace(/^\/+home\/user\/(?:project\/)?/i, "");
  s = s.replace(/^\/+/, "");
  // Resolve alias @/
  if (s.startsWith("@/")) {
    s = s.replace(/^@\//, hasSrc ? "src/" : "");
  }
  // Se veio apenas o nome do arquivo, prefira app/ (landing page única)
  if (s && !s.includes("/")) {
    s = `${hasSrc ? "src/" : ""}app/${s}`;
  }
  // Garante extensão
  if (!/\.(tsx|ts|jsx|js)$/i.test(s)) {
    s = `${s}.tsx`;
  }
  // Normaliza segmentos . e ..
  s = s
    .split("/")
    .filter(Boolean)
    .reduce<string[]>((stack, seg) => {
      if (seg === ".") return stack;
      if (seg === "..") {
        stack.pop();
        return stack;
      }
      stack.push(seg);
      return stack;
    }, [])
    .join("/");
  return s;
}

function toPascalCase(name: string): string {
  return name
    .replace(/\.(tsx|ts|jsx|js)$/i, "")
    .split(/[^A-Za-z0-9]+/)
    .filter(Boolean)
    .map((p) => p.charAt(0).toUpperCase() + p.slice(1))
    .join("");
}

function toKebabCase(name: string): string {
  return name
    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
    .replace(/\s+/g, '-')
    .toLowerCase();
}

// Check if a path is allowed, supporting folder wildcards like components/ui/*
function isPathAllowed(p: string, guard: Set<string>): boolean {
  if (guard.size === 0) return true;
  if (guard.has(p)) return true;
  for (const g of guard) {
    if (g.endsWith("/*")) {
      const prefix = g.slice(0, -2);
      if (p.startsWith(prefix)) return true;
    }
    if (g.endsWith("/")) {
      if (p.startsWith(g)) return true;
    }
  }
  return false;
}

// Normalize component paths: route page sections into app/ and fix common typos
function mapComponentPath(p: string): string {
  let out = p.replace(/princing/gi, "pricing");
  // Normalize app/<kebab>.tsx -> app/<PascalCase>.tsx for sections
  const appFile = out.match(/^app\/([^\/]+)\.(tsx|ts|jsx|js)$/i);
  if (appFile) {
    const base = appFile[1];
    if (/-/.test(base) && !/^page$/i.test(base)) {
      return `app/${toPascalCase(base)}.${appFile[2]}`;
    }
  }
  // components/blocks/* -> app/<PascalCase>.tsx
  if (/^components\/blocks\//i.test(out)) {
    const base = out.split("/").pop() || "Component.tsx";
    const pascal = toPascalCase(base);
    return `app/${pascal}.tsx`;
  }
  // If looks like a page section under components/ui, move to app/<PascalCase>.tsx
  const m = out.match(/^components\/ui\/([^\/]+)\.(tsx|ts|jsx|js)$/i);
  if (m) {
    const name = m[1];
    if (/(hero|pricing|feature|testimonial|footer|header|section|banner|clients?|logos?|gallery|video|background|signup|email|cta)/i.test(name)) {
      return `app/${toPascalCase(name)}.tsx`;
    }
  }
  return out;
}

// Heurística: evitar overwrite destrutivo em app/page.*
function shouldBlockDestructivePageWrite(prev: string, next: string): boolean {
  if (!prev) return false;
  const ratio = next.length / Math.max(prev.length, 1);
  const importNames = Array.from(prev.matchAll(/import\s+([\s\S]*?)from\s+['"][^'"]+['"]/g))
    .flatMap((m) => {
      const spec = (m[1] || "").trim();
      const names: string[] = [];
      const named = spec.match(/\{([^}]+)\}/);
      if (named) {
        for (const n of named[1].split(",")) names.push(n.trim().split(/\s+as\s+/)[0]);
      }
      const def = spec.replace(named?.[0] || "", "").trim().replace(/^,/, "").trim();
      if (def) names.push(def);
      return names.filter(Boolean);
    })
    .filter(Boolean);
  const usedNames = new Set(importNames.filter((n) => new RegExp(`<${n}\\b`).test(prev)));
  const stillUsed = Array.from(usedNames).filter((n) => new RegExp(`<${n}\\b`).test(next));
  if (ratio < 0.6 && usedNames.size >= 2 && stillUsed.length <= 0) return true;
  return false;
}

function ensureImportLine(src: string, importLine: string): string {
  if (!importLine?.trim()) return src;
  if (src.includes(importLine.trim())) return src;
  const lines = src.split("\n");
  let insertIdx = 0;
  if (/^\s*['"]use client['"]\s*;?/.test(lines[0] || "")) insertIdx = 1;
  for (let i = insertIdx; i < lines.length; i++) {
    if (/^\s*import\s+/.test(lines[i])) insertIdx = i + 1;
    else if (lines[i].trim() && !/^\s*(\/\*|\/\/)/.test(lines[i])) break;
  }
  lines.splice(insertIdx, 0, importLine.trim());
  return lines.join("\n");
}

function insertJsxIntoMain(src: string, jsx: string, position: "prepend" | "append" = "prepend"): string {
  const openIdx = src.search(/<main\b[^>]*>/i);
  const closeIdx = src.search(/<\/main>/i);
  if (openIdx !== -1 && closeIdx !== -1 && closeIdx > openIdx) {
    const afterOpen = src.indexOf(">", openIdx) + 1;
    if (position === "prepend") {
      return src.slice(0, afterOpen) + `\n      ${jsx}\n` + src.slice(afterOpen);
    } else {
      return src.slice(0, closeIdx) + `\n      ${jsx}\n` + src.slice(closeIdx);
    }
  }
  const retIdx = src.indexOf("return");
  if (retIdx !== -1) {
    const paren = src.indexOf("(", retIdx);
    if (paren !== -1) {
      return src.slice(0, paren + 1) + `\n    ${jsx}\n` + src.slice(paren + 1);
    }
  }
  return src + `\n${jsx}\n`;
}

// Guard leve: evitar remoção acidental de seções críticas em app/page.* durante EDIÇÃO
function violatesCriticalSections(prev: string, next: string): string | null {
  const hadMain = /<main\b/i.test(prev);
  const hasMain = /<main\b/i.test(next);
  if (hadMain && !hasMain) return "main tag removed";
  const hadHeader = /<\s*(Navbar|header)\b/i.test(prev);
  const hasHeader = /<\s*(Navbar|header)\b/i.test(next);
  if (hadHeader && !hasHeader) return "header/navbar removed";
  const hadFooter = /<\s*(Footer|footer)\b/i.test(prev);
  const hasFooter = /<\s*(Footer|footer)\b/i.test(next);
  if (hadFooter && !hasFooter) return "footer removed";
  return null;
}

// Extrai nomes importados (default, named e "as") de um arquivo para detectar conflitos
function extractImportedNames(src: string): string[] {
  const importNames = Array.from(src.matchAll(/import\s+([\s\S]*?)from\s+['"][^'"]+['"]/g))
    .flatMap((m) => {
      const spec = (m[1] || "").trim();
      const names: string[] = [];
      const named = spec.match(/\{([^}]+)\}/);
      if (named) {
        for (const n of named[1].split(",")) {
          const parts = n.trim().split(/\s+as\s+/);
          names.push((parts[1] || parts[0]).trim());
        }
      }
      const def = spec.replace(named?.[0] || "", "").trim().replace(/^,/, "").trim();
      if (def) names.push(def);
      return names.filter(Boolean);
    });
  return importNames;
}

// Ensure imported alias does not collide with existing imports in prevSrc
function ensureUniqueAlias(importLine: string, prevSrc: string, jsx: string): { importLine: string; jsx: string } {
  const candidates: string[] = [];
  const def = importLine.match(/import\s+([A-Za-z_$][\w$]*)\s*(?:,|\s+from)/)?.[1];
  if (def) candidates.push(def);
  const namedGroup = importLine.match(/\{([^}]+)\}/);
  if (namedGroup) {
    for (const n of namedGroup[1].split(",")) {
      const parts = n.trim().split(/\s+as\s+/);
      const local = (parts[1] || parts[0]).trim();
      if (local) candidates.push(local);
    }
  }
  const alias = candidates[0];
  if (!alias) return { importLine, jsx };

  const used = new Set(extractImportedNames(prevSrc));
  if (!used.has(alias)) return { importLine, jsx };

  const special = /from\s+['"][^'"]*horizon-hero-section[^'"]*['"]/i.test(importLine) ? "HorizonHeroSection" : undefined;
  const base = special || `${alias}New`;
  let candidate = base;
  let i = 2;
  while (used.has(candidate)) candidate = `${base}${i++}`;

  // Replace alias in importLine
  let nextImport = importLine
    // default import
    .replace(new RegExp(`\bimport\s+${alias}\b`), `import ${candidate}`)
    // named import with as
    .replace(new RegExp(`\bas\s+${alias}\b`), `as ${candidate}`)
    // named import without as (best-effort inside braces)
    .replace(/(\{[^}]*\})/, (full) => full.replace(new RegExp(`(^|,)\s*${alias}(\s*,|$)`), (m: string) => m.replace(alias, candidate)));

  const nextJsx = jsx.replace(new RegExp(`<\s*${alias}\b`, "g"), `<${candidate}`);
  return { importLine: nextImport, jsx: nextJsx };
}

// Sanitize demo imports: replace @/components/ui/demo with real component paths
function sanitizeDemoImport(importLine: string, jsx: string, files: Record<string, string>): { importLine: string; jsx: string } {
  if (!/@\/components\/ui\/demo['"]?/i.test(importLine)) return { importLine, jsx };
  const imported =
    importLine.match(/\{\s*([A-Za-z_$][\w$]*)\s*(?:as\s*[A-Za-z_$][\w$]*)?\s*\}/)?.[1] ||
    importLine.match(/import\s+([A-Za-z_$][\w$]*)\s+from/)
      ?.[1] || "";
  const baseName = imported?.replace(/Demo$/i, "") || "Section";
  const appPath = `app/${baseName}.tsx`;
  const uiPath = `components/ui/${baseName.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase()}.tsx`;
  let newSpecifier = `./${baseName}`;
  if (!files[appPath] && files[uiPath]) {
    newSpecifier = `@/components/ui/${uiPath.split("/").pop()!.replace(/\.tsx?$/i, "")}`;
  }
  let nextImport = importLine.replace(/@\/components\/ui\/demo/gi, newSpecifier);
  if (imported) {
    nextImport = nextImport.replace(new RegExp(`\\b${imported}\\b`, "g"), baseName);
  }
  const nextJsx = imported ? jsx.replace(new RegExp(`<\\s*${imported}\\b`, "g"), `<${baseName}`) : jsx;
  return { importLine: nextImport, jsx: nextJsx };
}

// Rewrite imports from @/components/ui/<slug> to local app/<PascalCase> when that file exists
function sanitizeUiImportToApp(importLine: string, files: Record<string, string>): string {
  const m = importLine.match(/from\s+["']@\/components\/ui\/([^"']+)["']/i);
  if (!m) return importLine;
  const slug = m[1].split("/").pop() || "";
  if (!slug) return importLine;
  const baseName = toPascalCase(slug);
  const appPathTsx = `app/${baseName}.tsx`;
  const appPathTs = `app/${baseName}.ts`;
  if (files[appPathTsx] || files[appPathTs]) {
    return importLine.replace(/from\s+["']@\/components\/ui\/[^"']+["']/i, `from './${baseName}'`);
  }
  return importLine;
}

// Normalize content of files written under app/:
// - Fix relative imports using kebab-case (./creative-pricing -> ./CreativePricing)
// - Ensure Shadcn primitives import from @/components/ui/* (e.g., Button -> @/components/ui/button)
function normalizeAppFileContent(filePath: string, content: string): string {
  if (!/^app\//i.test(filePath) || typeof content !== 'string') return content;
  let out = content;

  // 1) Fix relative kebab-case imports to PascalCase
  out = out.replace(/from\s+(["'])\.\/(?!\.)([a-z0-9\-]+)(?:\.(?:tsx|ts|jsx|js))?\1/g, (m, quote, slug) => {
    const pascal = toPascalCase(slug);
    return m.replace(new RegExp(`\.\/${slug}`), `./${pascal}`);
  });

  // 2) Force Shadcn primitives to import from @/components/ui/<kebab>
  const primitiveMap: Record<string, string> = {
    Button: 'button',
    Input: 'input',
    Card: 'card',
    Badge: 'badge',
    Tabs: 'tabs',
    Sheet: 'sheet',
    Dialog: 'dialog',
    Tooltip: 'tooltip',
    Separator: 'separator',
  };
  out = out.replace(/import\s+([^;]+?)\s+from\s+(["'])([^"']+)\2\s*;?/g, (full, spec, q, src) => {
    // Already correct
    if (/^@\/components\/ui\//.test(src)) return full;
    // Only adjust if it's a relative import or bare and matches a known primitive name
    const names: string[] = [];
    const named = spec.match(/\{([^}]+)\}/);
    if (named) {
      for (const n of named[1].split(',')) {
        const local = n.trim().split(/\s+as\s+/).pop() || '';
        if (local) names.push(local);
      }
    }
    const def = spec.replace(named?.[0] || '', '').trim().replace(/^,/, '').trim();
    if (def) names.push(def);

    const found = names.find((n) => primitiveMap[n]);
    if (!found) return full;
    const kebab = primitiveMap[found] || toKebabCase(found);
    return `import ${spec} from ${q}@/components/ui/${kebab}${q};`;
  });

  return out;
}

// Force update of metadata title/description and html lang in layout source
function upsertMetadataInLayout(src: string, title: string, description: string): string {
  let next = String(src || "");

  // Ensure import of Metadata type
  if (!/\bMetadata\b/.test(next) || !/from\s+['"]next['"]/m.test(next)) {
    const lines = next.split("\n");
    let insertIdx = 0;
    if (/^\s*['"]use client['"];?\s*$/.test(lines[0] || "")) insertIdx = 1;
    // Avoid duplicate import
    const alreadyHas = lines.some((l) => /import\s+type\s+\{?\s*Metadata\s*\}?\s+from\s+['"]next['"]/i.test(l));
    if (!alreadyHas) {
      lines.splice(insertIdx, 0, `import type { Metadata } from "next";`);
      next = lines.join("\n");
    }
  }

  // Force html lang to pt-BR (replace any existing lang attr or add if missing)
  if (/<html\b[^>]*\blang\s*=/.test(next)) {
    next = next.replace(/<html\b([^>]*?)\blang\s*=\s*['"][^'\"]*['"]([^>]*)>/i, `<html$1 lang="pt-BR"$2>`);
  } else if (/<html\b/i.test(next)) {
    next = next.replace(/<html(\b[^>]*)>/i, `<html lang="pt-BR"$1>`);
  }

  // Replace existing metadata object or insert a new one before RootLayout
  const metaRe = /export\s+const\s+metadata\s*(?::\s*Metadata\s*)?=\s*\{([\s\S]*?)\}\s*;?/m;
  if (metaRe.test(next)) {
    next = next.replace(metaRe, (_full, body) => {
      let b = String(body);
      // title
      if (/\btitle\s*:/.test(b)) {
        b = b.replace(/\btitle\s*:\s*([^,}]+)(?=([^}]*))(,?)/, `title: ${JSON.stringify(title)}$3`);
      } else {
        b = `  title: ${JSON.stringify(title)},\n` + b.replace(/^\s+/, "");
      }
      // description
      if (/\bdescription\s*:/.test(b)) {
        b = b.replace(/\bdescription\s*:\s*([^,}]+)(?=([^}]*))(,?)/, `description: ${JSON.stringify(description)}$3`);
      } else {
        // insert after title if present
        if (/\btitle\s*:/.test(b)) {
          b = b.replace(/(\btitle\s*:\s*[^,}]+,?)/, `$1\n  description: ${JSON.stringify(description)},`);
        } else {
          b = `  description: ${JSON.stringify(description)},\n` + b.replace(/^\s+/, "");
        }
      }
      return `export const metadata: Metadata = {\n${b.trim()}\n};`;
    });
  } else {
    next = next.replace(
      /export\s+default\s+function\s+RootLayout\b/,
      `export const metadata: Metadata = {\n  title: ${JSON.stringify(title)},\n  description: ${JSON.stringify(description)}\n};\n\nexport default function RootLayout`
    );
    // If replace failed (no RootLayout found), append metadata at top
    if (!/export\s+const\s+metadata\b/.test(next)) {
      next = `export const metadata: Metadata = {\n  title: ${JSON.stringify(title)},\n  description: ${JSON.stringify(description)}\n};\n\n` + next;
    }
  }

  return next;
}

export const codeAgentFunction = inngest.createFunction(
  { id: "code-agent" },
  { event: "code-agent/run" },
  async ({ event, step }) => {
    console.log("Starting code-agent function", JSON.stringify(event.data));
    const sandboxId = await getOrCreateSandboxId(step);

    const previousMessages = await step.run(
      "get-previous-messages",
      async () => {
        console.log("Running get-previous-messages");
        const formattedMessages: Message[] = [];

        const messages = await prisma.message.findMany({
          where: {
            projectId: event.data.projectId,
          },
          orderBy: {
            createdAt: "desc",
          },
          take: 5,
        });

        for (const message of messages) {
          formattedMessages.push({
            type: "text",
            role: message.role === "ASSISTANT" ? "assistant" : "user",
            content: message.content,
          });
        }
        console.log("Completed get-previous-messages", formattedMessages.length, "messages");
        return formattedMessages.reverse();
      }
    );

    const state = createState<AgentState>(
      {
        summary: "",
        files: {},
      },
      {
        messages: previousMessages,
      }
    );

    const codeAgent = createAgent<AgentState>({
      name: "code-agent",
      description: "An expert coding agent",
      system: PROMPT,
      model: azureOpenAICompat({
        endpoint: process.env.AZURE_OPENAI_ENDPOINT!,
        apiKey: process.env.AZURE_OPENAI_5_API_KEY || process.env.AZURE_OPENAI_API_KEY!,
        deployment: process.env.AZURE_OPENAI_5_DEPLOYMENT || process.env.AZURE_OPENAI_DEPLOYMENT!,
        apiVersion: process.env.AZURE_OPENAI_5_API_VERSION || process.env.AZURE_OPENAI_API_VERSION!,
        defaultParameters: { temperature: 0.1 },
      }),
      tools: [
        createTool({
          name: "terminal",
          description: "Use the terminal to run commands",
          parameters: z.object({ command: z.string() }),
          handler: async ({ command }, { step }) => {
            console.log("Running terminal tool", command);
            return await step?.run("terminal", async () => {
              const buffers = { stdout: "", stderr: "" };
              try {
                const sandbox = await getSandbox(sandboxId);
                const result = await sandbox.commands.run(command, {
                  onStdout: (data: string) => { buffers.stdout += data; },
                  onStderr: (data: string) => { buffers.stderr += data; },
                });
                console.log("Completed terminal tool", result.exitCode);
                return result.stdout;
              } catch (error) {
                console.error(`command failed: ${error}\nstdOut: ${buffers.stdout}\nstdError: ${buffers.stderr}`);
                return `command failed: ${error}\nstdOut: ${buffers.stdout}\nstdError: ${buffers.stderr}`;
              }
            });
          },
        }),
        createTool({
          name: "createOrUpdateFiles",
          description: "Create or update files in the sandbox",
          parameters: z.object({
            files: z.array(z.object({ path: z.string(), content: z.string() })),
          }),
          handler: async ({ files }, { step, network }: Tool.Options<AgentState>) => {
            console.log("Running createOrUpdateFiles tool", files.length, "files");
            const newFiles = await step?.run("createOrUpdateFiles", async () => {
              try {
                const updatedFiles = network.state.data.files || {};
                const sandbox = await getSandbox(sandboxId);
                const hasSrc = Object.keys(updatedFiles).some((p) => p.startsWith("src/"));
                const guard = new Set<string>((network.state.data.allowedPaths || []) as string[]);
                for (const file of files) {
                  let normalized = normalizeSandboxPath(file.path, hasSrc);
                  normalized = mapComponentPath(normalized);
                  if (!isPathAllowed(normalized, guard)) {
                    console.warn(`[edit-guard] blocked write to ${normalized}`);
                    continue;
                  }
                  if (/^app\/page\.(tsx|jsx|ts|js)$/i.test(normalized)) {
                    const prev = typeof updatedFiles[normalized] === "string"
                      ? (updatedFiles[normalized] as string)
                      : await (async () => { try { return await sandbox.files.read(normalized); } catch { return ""; } })();
                    if (shouldBlockDestructivePageWrite(prev || "", file.content)) {
                      console.warn("[safe-merge] blocked destructive overwrite of app/page.*; use safeUpdatePage tool");
                      return `Blocked destructive overwrite of ${normalized}. Use safeUpdatePage tool to insert new hero without removing existing content.`;
                    }
                  }
                  if (/\/demo\.(tsx|jsx|ts|js)$/i.test(normalized)) {
                    console.warn(`[policy] demo files are not allowed: ${normalized}`);
                    continue;
                  }
                  if (/app\/page\.(tsx|jsx|ts|js)$/i.test(normalized) && DEFAULT_NEXT_TEMPLATE_RE.test(file.content)) {
                    console.warn("Template guard: skipping overwrite of app/page.* with Next.js starter content");
                    continue;
                  }
                  const finalContent = normalizeAppFileContent(normalized, file.content);
                  await sandbox.files.write(normalized, finalContent);
                  updatedFiles[normalized] = finalContent;
                }
                console.log("Completed createOrUpdateFiles tool");
                return updatedFiles;
              } catch (error) {
                console.log("Error in createOrUpdateFiles", error);
                return "Error: " + error;
              }
            });
            if (typeof newFiles === "object") {
              const prev = (network.state.data.files || {}) as Record<string, string>;
              network.state.data.files = { ...prev, ...(newFiles as any) } as any;
            }
          },
        }),
        createTool({
          name: "safeUpdatePage",
          description: "Non-destructive update for app/page.*. Inserts a component into <main> and ensures import; preserves the rest of the file.",
          parameters: z.object({
            filePath: z.string().default("app/page.tsx"),
            importLine: z.string(),
            jsx: z.string(),
            position: z.enum(["prepend", "append"]).default("append"),
          }),
          handler: async ({ filePath, importLine, jsx, position }, { step, network }) => {
            return await step?.run("safeUpdatePage", async () => {
              const sandbox = await getSandbox(sandboxId);
              const filesState = network.state.data.files || {};
              const hasSrc = Object.keys(filesState).some((p) => p.startsWith("src/")) ||
                (await (async () => { try { await sandbox.files.read("src/app/page.tsx"); return true; } catch { return false; } })());
              const path = normalizeSandboxPath(filePath, hasSrc);
              const guard = new Set<string>((network.state.data.allowedPaths || []) as string[]);
              if (!isPathAllowed(path, guard)) return `Blocked: ${path} not in allowedPaths.`;
              let prev = "";
              try { prev = await sandbox.files.read(path); } catch {}
              // If file missing or it's the default Next.js starter, start from a minimal shell
              if (!prev || DEFAULT_NEXT_TEMPLATE_RE.test(prev)) {
                prev = `"use client";\n\nexport default function Page(){\n  return (<main className=\"min-h-screen w-full\"></main>);\n}\n`;
              }
              // First, prefer local app/<PascalCase> if exists for any ui import
              const importPreferred = sanitizeUiImportToApp(importLine, filesState as Record<string, string>);
              const sanitized = sanitizeDemoImport(importPreferred, jsx, filesState as Record<string, string>);
              const adjusted = ensureUniqueAlias(sanitized.importLine, prev, sanitized.jsx);
              const fixedImport = adjusted.importLine;
              const fixedJsx = adjusted.jsx;
              let next = ensureImportLine(prev, fixedImport);
              next = insertJsxIntoMain(next, fixedJsx, position);
              await sandbox.files.write(path, next);
              network.state.data.files[path] = next;
              return `Updated ${path} with safe merge`;
            });
          },
        }),
        createTool({
          name: "readFiles",
          description: "Read files from the sandbox",
          parameters: z.object({ files: z.array(z.string()) }),
          handler: async ({ files }, { step, network }) => {
            console.log("Running readFiles tool", files.length, "files");
            return await step?.run("readFiles", async () => {
              try {
                const sandbox = await getSandbox(sandboxId);
                const existing = network.state.data.files || {};
                const hasSrc = Object.keys(existing).some((p) => p.startsWith("src/"));
                const contents: { path: string; content: string | null }[] = [];
                for (const raw of files) {
                  const p = normalizeSandboxPath(raw, hasSrc);
                  try {
                    const content = await sandbox.files.read(p);
                    contents.push({ path: p, content });
                  } catch (e: any) {
                    const msg = String(e?.message || e);
                    if (/NotFound/i.test(msg)) {
                      console.warn(`[readFiles] not found: ${p}`);
                      contents.push({ path: p, content: null });
                      continue;
                    }
                    throw e;
                  }
                }
                console.log("Completed readFiles tool", contents.length, "files read");
                return JSON.stringify(contents);
              } catch (error) {
                console.log("Error in readFiles", error);
                return "Error: " + error;
              }
            });
          },
        }),
      ],
      lifecycle: {
        onResponse: async ({ result, network }) => {
          logAssistantTexts("code-agent", result.output);
          console.log("Running onResponse lifecycle");
          const lastAssistantTextMessageText = lastAssistantTextMessageContent(result);
          if (lastAssistantTextMessageText && network) {
            if (lastAssistantTextMessageText.includes("<task_summary>")) {
              network.state.data.summary = lastAssistantTextMessageText;
            }
          }
          console.log("Completed onResponse lifecycle");
          return result;
        },
      },
    });

    const network = createNetwork<AgentState>({
      name: "coding-agent-network",
      agents: [codeAgent],
      maxIter: 15,
      defaultState: state,
      router: async ({ network }) => {
        console.log("Running router");
        const summary = network.state.data.summary;

        if (summary) {
          console.log("Router: summary exists, ending");
          return;
        }
        console.log("Router: no summary, routing to codeAgent");
        return codeAgent;
      },
    });

    // Compose an enriched instruction including customization
    const customization = (event.data as any).customization as
      | {
          analytics?: { provider: string; code?: string };
          components?: Record<string, { enabled: boolean; prompt?: string; border?: { enabled: boolean; prompt?: string } }>;
          theme?: { paletteId: string; paletteName: string; colors: string[] };
        }
      | undefined;

    const selectedComponents = Object.entries(customization?.components || {})
      .filter(([, cfg]) => cfg.enabled)
      .map(([key, cfg]) => ({ key, prompt: cfg.prompt, borderPrompt: cfg.border?.prompt }));

    const enrichedInstruction = [
      event.data.value,
      selectedComponents.length
        ? `\n\nComponents to include (in order if applicable):\n${selectedComponents
            .map(
              (c, i) => ` ${i + 1}. ${c.key}${c.prompt ? `\n    prompt: ${c.prompt}` : ""}${c.borderPrompt ? `\n    border: ${c.borderPrompt}` : ""}`
            )
            .join("\n")}`
        : "",
      customization?.theme
        ? `\n\nColor palette (4 colors, use as base tokens): ${customization.theme.paletteName} — ${customization.theme.colors.join(", ")}`
        : "",
      customization?.analytics && customization.analytics.provider !== "none"
        ? `\n\nAnalytics: ${customization.analytics.provider}${customization.analytics.code ? ` (${customization.analytics.code.slice(0, 40)}...)` : ""}`
        : "",
    ]
      .filter(Boolean)
      .join("");

    const taskStepsGenerator = createTaskStepsAgent();

    const { output: taskStepsOutput } = await taskStepsGenerator.run(
      enrichedInstruction
    );
    logAssistantTexts("task-steps-generator", taskStepsOutput);
    console.log("Completed taskStepsGenerator.run");

    await step.run("save-steps", async () => {
      console.log("Running save-steps");
      const stepsMessage = await prisma.message.create({
        data: {
          projectId: event.data.projectId,
          content: parseAgentOutput(taskStepsOutput),
          role: "ASSISTANT",
          type: "STEPS",
        },
      });
      console.log("Completed save-steps", stepsMessage.id);
      return stepsMessage;
    });

    const result = await network.run(enrichedInstruction, { state });
    console.log("Completed network.run", result.state.data.summary ? "success" : "error");

  const fragmentTitleGenerator = createFragmentTitleAgent();

  const responseGenerator = createResponseAgent();

  const { output: fragmentTitleOutput } = await fragmentTitleGenerator.run(
      result.state.data.summary
    );
  logAssistantTexts("fragment-title-generator", fragmentTitleOutput);
    console.log("Completed fragmentTitleGenerator.run");

  const { output: responseOutput } = await responseGenerator.run(
      result.state.data.summary
    );
  logAssistantTexts("response-generator", responseOutput);
    console.log("Completed responseGenerator.run");

    // Ensure project metadata (title/description) in app/layout.*
    await ensureMetadataStep(step, result, sandboxId, "LandinsPage", "Landing Page criada no Landinfy.com");

    const isError =
      !result.state.data.summary ||
      Object.keys(result.state.data.files || {}).length === 0;

    // Best-effort analytics injection (Next.js App Router friendly)
    if (!isError && customization?.analytics && customization?.analytics?.provider !== "none") {
      await step.run("inject-analytics", async () => {
        try {
          console.log("Running inject-analytics");
          const rawSnippet = (customization?.analytics?.code || "").trim();
          if (!rawSnippet) return;

          // Parse one or more <script> tags; if none, treat as inline JS
          const scriptMatches = Array.from(rawSnippet.matchAll(/<script\b([^>]*)>([\s\S]*?)<\/script>/gi));
          const scripts = scriptMatches.length
            ? scriptMatches.map((mm) => ({ attrs: (mm[1] || "").trim(), content: (mm[2] || "").trim() }))
            : [{ attrs: "", content: rawSnippet }];

          const makePropsFromAttrs = (attrs: string) => {
            const idMatch = attrs.match(/\bid=["']([^"']+)["']/i);
            const srcMatch = attrs.match(/\bsrc=["']([^"']+)["']/i);
            const hasAsync = /\basync\b/i.test(attrs);
            const hasDefer = /\bdefer\b/i.test(attrs);
            const dataMatches = Array.from(attrs.matchAll(/\b(data-[\w-]+)=["']([^"']+)["']/gi));
            let props = `strategy="afterInteractive"`;
            if (idMatch?.[1]) props += ` id="${idMatch[1]}"`;
            if (srcMatch?.[1]) props += ` src="${srcMatch[1]}"`;
            if (hasAsync) props += ` async`;
            if (hasDefer) props += ` defer`;
            for (const m of dataMatches) {
              const k = m[1];
              const v = m[2];
              props += ` ${k}="${v}"`;
            }
            return { props, hasSrc: !!srcMatch?.[1] };
          };

          const files = result.state.data.files || {};
          const sandbox = await getSandbox(sandboxId);

          // Try to find layout both in memory and in sandbox
          const inMemory = Object.keys(files).find((p) => /^(src\/)?app\/layout\.(tsx|jsx|ts|js)$/i.test(p));
          const candidates = [
            "src/app/layout.tsx","src/app/layout.jsx","src/app/layout.ts","src/app/layout.js",
            "app/layout.tsx","app/layout.jsx","app/layout.ts","app/layout.js",
          ];
          let layoutPath = inMemory;
          let layoutRaw = layoutPath ? String(files[layoutPath] || "") : "";
          if (!layoutPath || !layoutRaw) {
            for (const p of candidates) {
              try {
                const r = await sandbox.files.read(p);
                if (r && typeof r === "string") { layoutPath = p; layoutRaw = r; break; }
              } catch {}
            }
          }

          if (layoutPath && layoutRaw) {
            // 1) Write analytics component alongside layout (supports src/ and non-src projects)
            const hasSrc = /^src\//i.test(layoutPath);
            const analyticsPath = hasSrc ? "src/app/analytics.tsx" : "app/analytics.tsx";
            // Build one <Script> per parsed <script> tag
            const lines = scripts
              .map((s, idx) => {
                const { props, hasSrc } = makePropsFromAttrs(s.attrs);
                if (hasSrc) {
                  return `      <Script ${props} />`;
                }
                const escaped = s.content
                  .replace(/`/g, "\\`")
                  .replace(/\$\{/g, "\\${");
                const needsId = !/\bid=/.test(props);
                const idProp = needsId ? ` id={\"custom-analytics-${idx}\"}` : "";
                return `      <Script ${props}${idProp} dangerouslySetInnerHTML={{ __html: \`${escaped}\` }} />`;
              })
              .join("\n");
            const analyticsContent = `"use client";\nimport Script from 'next/script';\nexport default function AppAnalytics() {\n  return (\n    <>\n${lines}\n    </>\n  );\n}\n`;
            await sandbox.files.write(analyticsPath, analyticsContent);
            result.state.data.files[analyticsPath] = analyticsContent;

            // 2) Inject import and <AppAnalytics /> into layout
            let nextLayout = layoutRaw;
            const hasImport = /from\s+['"]\.\/analytics['"]/m.test(nextLayout);
            if (!hasImport) {
              if (/^import\s/m.test(nextLayout)) {
                nextLayout = nextLayout.replace(/^(import[\s\S]*?;\s*)/m, `$1\nimport AppAnalytics from './analytics';\n`);
              } else {
                nextLayout = `import AppAnalytics from './analytics';\n` + nextLayout;
              }
            }
            if (!/\<AppAnalytics\s*\/>/m.test(nextLayout)) {
              const bodyIdx = nextLayout.search(/<body[^>]*>/i);
              if (bodyIdx !== -1) {
                const insertPos = nextLayout.indexOf('>', bodyIdx) + 1;
                nextLayout = nextLayout.slice(0, insertPos) + `\n      <AppAnalytics />` + nextLayout.slice(insertPos);
              } else {
                nextLayout = nextLayout.replace(/(\{\s*children\s*\})/m, `<AppAnalytics />\n      $1`);
              }
            }
            await sandbox.files.write(layoutPath, nextLayout);
            result.state.data.files[layoutPath] = nextLayout;
            console.log("Completed inject-analytics via layout");
            return;
          }

          // Fallbacks: try raw head injection or create app/head.tsx based on in-memory files
          const buildRawScriptTag = (attrs: string, content: string) => {
            const idMatch = attrs.match(/\bid=["']([^"']+)["']/i);
            const srcMatch = attrs.match(/\bsrc=["']([^"']+)["']/i);
            const hasAsync = /\basync\b/i.test(attrs);
            const hasDefer = /\bdefer\b/i.test(attrs);
            const dataMatches = Array.from(attrs.matchAll(/\b(data-[\w-]+)=["']([^"']+)["']/gi));
            let attrStr = "";
            if (idMatch?.[1]) attrStr += ` id=\"${idMatch[1]}\"`;
            if (srcMatch?.[1]) attrStr += ` src=\"${srcMatch[1]}\"`;
            if (hasAsync) attrStr += ` async`;
            if (hasDefer) attrStr += ` defer`;
            for (const m of dataMatches) {
              const k = m[1];
              const v = m[2];
              attrStr += ` ${k}=\"${v}\"`;
            }
            if (srcMatch?.[1]) {
              return `<script${attrStr}></script>`;
            }
            // Escape closing script tags if present in content to avoid early termination
            const safeContent = content.replace(/<\/script>/gi, "<\\/script>");
            return `<script${attrStr}>\n${safeContent}\n</script>`;
          };

          const headScriptsHtml = scripts.map((s) => buildRawScriptTag(s.attrs, s.content)).join("\n");

          let targetPath: string | undefined;
          let updatedContent: string | undefined;
          for (const [p, content] of Object.entries(files)) {
            const c = String(content || "");
            if (c.includes("</head>")) {
              updatedContent = c.replace(/<\/head>/i, `\n  {/* Analytics */}\n${headScriptsHtml}\n</head>`);
              targetPath = p;
              break;
            }
          }
          if (!updatedContent) {
            targetPath = "app/head.tsx";
            const joined = headScriptsHtml;
            updatedContent = `export default function Head() {\n  return (\n    <>\n      {/* Analytics */}\n      <>${joined}</>\n    </>\n  );\n}\n`;
          }
          if (targetPath && updatedContent) {
            await sandbox.files.write(targetPath, updatedContent);
            result.state.data.files[targetPath] = updatedContent;
            console.log("Completed inject-analytics via head fallback");
          }
        } catch (err) {
          console.warn("Analytics injection failed", err);
        }
      });
    }

    // Cleanup: remove orphan ClarityAnalytics component files if present
    if (!isError) {
      await step.run("cleanup-orphan-analytics", async () => {
        try {
          const sandbox = await getSandbox(sandboxId);
          try {
            await sandbox.commands.run("bash -lc \"rm -f app/ClarityAnalytics.tsx src/app/ClarityAnalytics.tsx\"");
          } catch {}
          const files = (result.state.data.files || {}) as Record<string, string>;
          delete files["app/ClarityAnalytics.tsx"];
          delete files["src/app/ClarityAnalytics.tsx"];
        } catch (e) {
          console.warn("cleanup-orphan-analytics failed", e);
        }
      });
    }

    // Post-process: fix common export issues (versions, tailwind/shadcn, missing UI stubs)
    if (!isError) {
      await step.run("postprocess-project", async () => {
        const sandbox = await getSandbox(sandboxId);

        // Helper: safe read
        const readSafe = async (p: string) => {
          try {
            return await sandbox.files.read(p);
          } catch {
            return undefined;
          }
        };

        // 0) Ensure 'use client' directive is the very first line when present
        try {
          const moveUseClientToTop = (src: string) => {
            if (!/['"]use client['"]/m.test(src)) return src;
            // Remove all occurrences of the directive and re-insert at the top
            const withoutAll = src.replace(/^[\s;]*["']use client["']\s*;?\s*/gm, "");
            return `"use client";\n` + withoutAll.replace(/^\s+/, "");
          };
          const entries = Object.entries(result.state.data.files || {});
          for (const [path, content] of entries) {
            if (typeof content !== "string") continue;
            if (!/\.(tsx|jsx)$/i.test(path)) continue;
            const fixed = moveUseClientToTop(content);
            if (fixed !== content) {
              await sandbox.files.write(path, fixed);
              result.state.data.files[path] = fixed;
            }
          }
        } catch (e) {
          console.warn("postprocess: move 'use client' to top failed", e);
        }

        // 1) Sanitize package.json: versions like ^latest/~latest, invalid package names, fix next-themes
        try {
          const pkgPath = "package.json";
          const pkgRaw = await readSafe(pkgPath);
          if (pkgRaw) {
            const pkg = JSON.parse(pkgRaw);
            const fix = (deps?: Record<string, string>) => {
              if (!deps) return;
              for (const k of Object.keys(deps)) {
                const v = deps[k];
                // Remove clearly invalid package names (import paths accidentally added to deps)
                if (/\//.test(k) && !k.startsWith("@")) {
                  delete deps[k];
                  continue;
                }
                if (k === "next/font/google" || k === "motion/react") {
                  delete deps[k];
                  continue;
                }
                // Normalize invalid tags
                if (typeof v === "string") {
                  const vv = v.trim();
                  if (/^\^latest$/i.test(vv) || /^~latest$/i.test(vv)) {
                    deps[k] = "latest";
                  }
                  // next-themes bogus versions – set to a known good range
                  if (k === "next-themes") {
                    if (!/^\d/.test(vv) && !/^~?\^?\d/.test(vv)) {
                      deps[k] = "^0.3.0";
                    }
                  }
                }
              }
            };
            fix(pkg.dependencies);
            fix(pkg.devDependencies);
            fix(pkg.peerDependencies);
            fix(pkg.optionalDependencies);
            const nextRaw = JSON.stringify(pkg, null, 2) + "\n";
            if (nextRaw !== pkgRaw) {
              await sandbox.files.write(pkgPath, nextRaw);
              result.state.data.files[pkgPath] = nextRaw;
            }
          }
        } catch (e) {
          console.warn("postprocess: package.json sanitize failed", e);
        }

        // 2) Ensure Tailwind config and shadcn tokens (prefer CJS for compatibility)
        try {
          const twPaths = [
            "tailwind.config.cjs",
            "tailwind.config.js",
            "tailwind.config.mjs",
            "tailwind.config.ts",
          ];
          let twPath: string | undefined;
          let twRaw: string | undefined;
          for (const p of twPaths) {
            const r = await readSafe(p);
            if (r) {
              twPath = p;
              twRaw = r;
              break;
            }
          }
          const shadcnTwCjs = `/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  darkMode: ['class'],\n  content: [\n    './app/**/*.{ts,tsx}',\n    './components/**/*.{ts,tsx}',\n    './pages/**/*.{ts,tsx}',\n    './src/**/*.{ts,tsx}',\n  ],\n  theme: {\n    extend: {\n      colors: {\n        border: 'hsl(var(--border))',\n        input: 'hsl(var(--input))',\n        ring: 'hsl(var(--ring))',\n        background: 'hsl(var(--background))',\n        foreground: 'hsl(var(--foreground))',\n        primary: { DEFAULT: 'hsl(var(--primary))', foreground: 'hsl(var(--primary-foreground))' },\n        secondary: { DEFAULT: 'hsl(var(--secondary))', foreground: 'hsl(var(--secondary-foreground))' },\n        destructive: { DEFAULT: 'hsl(var(--destructive))', foreground: 'hsl(var(--destructive-foreground))' },\n        muted: { DEFAULT: 'hsl(var(--muted))', foreground: 'hsl(var(--muted-foreground))' },\n        accent: { DEFAULT: 'hsl(var(--accent))', foreground: 'hsl(var(--accent-foreground))' },\n        popover: { DEFAULT: 'hsl(var(--popover))', foreground: 'hsl(var(--popover-foreground))' },\n        card: { DEFAULT: 'hsl(var(--card))', foreground: 'hsl(var(--card-foreground))' },\n      },\n      borderRadius: {\n        lg: 'var(--radius)',\n        md: 'calc(var(--radius) - 2px)',\n        sm: 'calc(var(--radius) - 4px)',\n      },\n    },\n  },\n  plugins: [],\n}\n`;
          const needsWrite = !twRaw || !/colors:\s*\{[\s\S]*border:/m.test(twRaw) || !/content:\s*\[/m.test(twRaw);
          if (needsWrite) {
            const pathToWrite = twPath && twPath.endsWith(".cjs") ? twPath : "tailwind.config.cjs";
            await sandbox.files.write(pathToWrite, shadcnTwCjs);
            result.state.data.files[pathToWrite] = shadcnTwCjs;
          }
        } catch (e) {
          console.warn("postprocess: tailwind config ensure failed", e);
        }

        // 2.5) Ensure next.config images allows picsum.photos
        try {
          const jsPath = "next.config.js";
          const mjsPath = "next.config.mjs";
          const jsRaw = await readSafe(jsPath);
          const mjsRaw = await readSafe(mjsPath);

          if (!jsRaw && !mjsRaw) {
            const cfg = `/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  images: { domains: ['picsum.photos'] },\n};\nmodule.exports = nextConfig;\n`;
            await sandbox.files.write(jsPath, cfg);
            result.state.data.files[jsPath] = cfg;
          } else if (jsRaw && !/picsum\.photos/.test(jsRaw)) {
            const patched = `${jsRaw}\n// Ensure picsum.photos domain for next/image\nmodule.exports.images = module.exports.images || {};\nmodule.exports.images.domains = Array.from(new Set([...(module.exports.images.domains || []), 'picsum.photos']));\n`;
            await sandbox.files.write(jsPath, patched);
            result.state.data.files[jsPath] = patched;
          }
        } catch (e) {
          console.warn("postprocess: ensure next.config images failed", e);
        }

        // 3) Ensure globals.css has CSS variables for shadcn
        try {
          const gPath = "app/globals.css";
          const gRaw = await readSafe(gPath);
          const baseCss = `@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer base {\n  :root {\n    --background: 0 0% 100%;\n    --foreground: 222.2 84% 4.9%;\n    --card: 0 0% 100%;\n    --card-foreground: 222.2 84% 4.9%;\n    --popover: 0 0% 100%;\n    --popover-foreground: 222.2 84% 4.9%;\n    --primary: 221.2 83.2% 53.3%;\n    --primary-foreground: 210 40% 98%;\n    --secondary: 210 40% 96.1%;\n    --secondary-foreground: 222.2 47.4% 11.2%;\n    --muted: 210 40% 96.1%;\n    --muted-foreground: 215.4 16.3% 46.9%;\n    --accent: 210 40% 96.1%;\n    --accent-foreground: 222.2 47.4% 11.2%;\n    --destructive: 0 84.2% 60.2%;\n    --destructive-foreground: 210 40% 98%;\n    --border: 214.3 31.8% 91.4%;\n    --input: 214.3 31.8% 91.4%;\n    --ring: 221.2 83.2% 53.3%;\n    --radius: 0.5rem;\n  }\n  .dark {\n    --background: 222.2 84% 4.9%;\n    --foreground: 210 40% 98%;\n    --card: 222.2 84% 4.9%;\n    --card-foreground: 210 40% 98%;\n    --popover: 222.2 84% 4.9%;\n    --popover-foreground: 210 40% 98%;\n    --primary: 217.2 91.2% 59.8%;\n    --primary-foreground: 222.2 47.4% 11.2%;\n    --secondary: 217.2 32.6% 17.5%;\n    --secondary-foreground: 210 40% 98%;\n    --muted: 217.2 32.6% 17.5%;\n    --muted-foreground: 215 20.2% 65.1%;\n    --accent: 217.2 32.6% 17.5%;\n    --accent-foreground: 210 40% 98%;\n    --destructive: 0 62.8% 30.6%;\n    --destructive-foreground: 0 85.7% 97.3%;\n    --border: 217.2 32.6% 17.5%;\n    --input: 217.2 32.6% 17.5%;\n    --ring: 224.3 76.3% 48%;\n  }\n}\n`;
          if (!gRaw || !/:root\s*\{[\s\S]*--background:/m.test(gRaw)) {
            const out = gRaw ? `${baseCss}\n${gRaw}` : baseCss;
            await sandbox.files.write(gPath, out);
            result.state.data.files[gPath] = out;
          }
        } catch (e) {
          console.warn("postprocess: globals.css ensure failed", e);
        }

        // 4) Ensure tsconfig paths for @/*
        try {
          const tsPath = "tsconfig.json";
          const tsRaw = await readSafe(tsPath);
          if (tsRaw) {
            const ts = JSON.parse(tsRaw);
            ts.compilerOptions = ts.compilerOptions || {};
            ts.compilerOptions.baseUrl = ts.compilerOptions.baseUrl || ".";
            ts.compilerOptions.paths = ts.compilerOptions.paths || {};
            if (!ts.compilerOptions.paths["@/*"]) {
              ts.compilerOptions.paths["@/*"] = ["./*"];
            }
            const next = JSON.stringify(ts, null, 2) + "\n";
            if (next !== tsRaw) {
              await sandbox.files.write(tsPath, next);
              result.state.data.files[tsPath] = next;
            }
          }
        } catch (e) {
          console.warn("postprocess: tsconfig ensure failed", e);
        }

        // 5) Ensure lib/utils.ts with cn
        try {
          const utilPath = "lib/utils.ts";
          const utilRaw = await readSafe(utilPath);
          if (!utilRaw) {
            const content = `import { type ClassValue } from 'clsx';\nimport { clsx } from 'clsx';\nimport { twMerge } from 'tailwind-merge';\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n`;
            await sandbox.files.write(utilPath, content);
            result.state.data.files[utilPath] = content;
          }
        } catch (e) {
          console.warn("postprocess: utils.ts ensure failed", e);
        }

        // 6) Stub missing UI components referenced anywhere in the project
        try {
          const importRegex = new RegExp(String.raw`import\s+([^'";]+)\s+from\s+["']@/components/ui/([^"']+)["'];?`, "g");
          const modules = new Map<string, string[]>();
          for (const [path, content] of Object.entries(result.state.data.files)) {
            if (typeof content !== "string") continue;
            if (!/(\.tsx|\.ts|\.jsx|\.js)$/i.test(path)) continue;
            const matches = content.matchAll(importRegex);
            for (const m of matches) {
              const spec = m[1].trim();
              const mod = m[2].trim();
              const names: string[] = [];
              const named = spec.match(/\{([^}]+)\}/);
              if (named) {
                for (const n of named[1].split(",")) names.push(n.trim().split(/\s+as\s+/)[0]);
              }
              const defMatch = spec.replace(named?.[0] || "", "").trim();
              if (defMatch && defMatch !== ",") names.push("default:" + defMatch);
              const prev = modules.get(mod) || [];
              modules.set(mod, prev.concat(names));
            }
          }
          for (const [mod, names] of modules) {
            const target = `components/ui/${mod}.tsx`;
            const exists = await readSafe(target);
            if (!exists) {
              if (mod === "accordion") {
                // Write a real shadcn-style accordion using Radix (no CSS files required)
                const content = `"use client";\n\nimport * as React from "react";\nimport * as AccordionPrimitive from "@radix-ui/react-accordion";\nimport { ChevronDown } from "lucide-react";\nimport { cn } from "@/lib/utils";\n\nconst Accordion = AccordionPrimitive.Root;\n\nconst AccordionItem = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>\n>(({ className, ...props }, ref) => (\n  <AccordionPrimitive.Item\n    ref={ref}\n    className={cn("border-b", className)}\n    {...props}\n  />\n));\nAccordionItem.displayName = "AccordionItem";\n\nconst AccordionTrigger = React.forwardRef<\n  HTMLButtonElement,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Header className="flex">\n    <AccordionPrimitive.Trigger\n      ref={ref}\n      className={cn(\n        "flex flex-1 items-center justify-between py-4 text-left font-medium transition-all hover:underline",\n        className\n      )}\n      {...props}\n    >\n      {children}\n      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200 data-[state=open]:rotate-180" />\n    </AccordionPrimitive.Trigger>\n  </AccordionPrimitive.Header>\n));\nAccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName;\n\nconst AccordionContent = React.forwardRef<\n  HTMLDivElement,\n  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>\n>(({ className, children, ...props }, ref) => (\n  <AccordionPrimitive.Content\n    ref={ref}\n    className={cn(\n      "overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down",\n      className\n    )}\n    {...props}\n  >\n    <div className="pb-4 pt-0">{children}</div>\n  </AccordionPrimitive.Content>\n));\nAccordionContent.displayName = AccordionPrimitive.Content.displayName;\n\nexport { Accordion, AccordionItem, AccordionTrigger, AccordionContent };\n`;
                await sandbox.files.write(target, content);
                result.state.data.files[target] = content;

                // Ensure dependency exists in package.json
                try {
                  const pkgPath = "package.json";
                  const pkgRaw = await readSafe(pkgPath);
                  if (pkgRaw) {
                    const pkg = JSON.parse(pkgRaw);
                    pkg.dependencies = pkg.dependencies || {};
                    if (!pkg.dependencies["@radix-ui/react-accordion"]) {
                      pkg.dependencies["@radix-ui/react-accordion"] = "latest";
                      const nextRaw = JSON.stringify(pkg, null, 2) + "\n";
                      await sandbox.files.write(pkgPath, nextRaw);
                      result.state.data.files[pkgPath] = nextRaw;
                    }
                  }
                } catch (e) {
                  console.warn("postprocess: add @radix-ui/react-accordion failed", e);
                }
              } else {
                // Fallback: lightweight stub
                const exports: string[] = [];
                const defaultName = names.find((n) => n.startsWith("default:"))?.split(":")[1];
                if (defaultName) {
                  exports.push(`const ${defaultName} = (props: any) => <div {...props} />;\nexport default ${defaultName};`);
                }
                const named = names.filter((n) => !n.startsWith("default:"));
                for (const n of named) {
                  if (!n) continue;
                  exports.push(`export const ${n} = (props: any) => <div {...props} />;`);
                }
                const stub = `"use client";\nimport React from 'react';\n${exports.join("\n")}\n`;
                await sandbox.files.write(target, stub);
                result.state.data.files[target] = stub;
              }
            }
          }
        } catch (e) {
          console.warn("postprocess: stub ui components failed", e);
        }

  // 7) Ensure shadcn components.json exists (helps users extend components later)
        try {
          const cfgPath = "components.json";
          const existing = await readSafe(cfgPath);
          if (!existing) {
            // Detect tailwind config file name written earlier
            const twJs = await readSafe("tailwind.config.js");
            const twCjs = await readSafe("tailwind.config.cjs");
            const twFile = twJs ? "tailwind.config.js" : twCjs ? "tailwind.config.cjs" : "tailwind.config.js";
            const cfg = {
              $schema: "https://ui.shadcn.com/schema.json",
              style: "default",
              rsc: true,
              tsx: true,
              tailwind: {
                config: twFile,
                css: "app/globals.css",
                baseColor: "slate",
                cssVariables: true,
                prefix: "",
              },
              aliases: { components: "@/components", utils: "@/lib/utils" },
            } as any;
            const raw = JSON.stringify(cfg, null, 2) + "\n";
            await sandbox.files.write(cfgPath, raw);
            result.state.data.files[cfgPath] = raw;
          }
        } catch (e) {
          console.warn("postprocess: components.json ensure failed", e);
        }

        // 8) Defensive: backgrounds shouldn't block clicks (don't force z-index to avoid hiding effects).
        try {
          const entries = Object.entries(result.state.data.files);
          for (const [path, content] of entries) {
            if (!/\.(tsx|jsx)$/.test(path)) continue;
            if (typeof content !== "string") continue;
            // Add pointer-events-none and select-none to common decorative background wrappers
            let next = content.replace(
              /(className=\"[^\"]*\babsolute\b[^\"]*\binset-0\b[^\"]*)(\")/g,
              (m, p1, p2) =>
                p1.includes("pointer-events-none") ? m : `${p1} pointer-events-none select-none${p2}`
            );
            if (next !== content) {
              await sandbox.files.write(path, next);
              result.state.data.files[path] = next;
            }
          }
        } catch (e) {
          console.warn("postprocess: background safety patch failed", e);
        }

        // 9) Ensure runtime deps for animations exist and are installed in sandbox
        try {
          const entries = Object.entries(result.state.data.files);
          let needsFramer = false;
          let needsSlot = false;
          for (const [path, content] of entries) {
            if (!/\.(tsx|ts|jsx|js)$/.test(path)) continue;
            if (typeof content !== "string") continue;
            if (/from\s+['"]framer-motion['"]/m.test(content)) needsFramer = true;
            if (/from\s+['"]@radix-ui\/react-slot['"]/m.test(content)) needsSlot = true;
          }
          const pkgPath = "package.json";
          const pkgRaw = await readSafe(pkgPath);
          if (pkgRaw) {
            const pkg = JSON.parse(pkgRaw);
            pkg.dependencies = pkg.dependencies || {};
            let changed = false;
            if (needsFramer && !pkg.dependencies["framer-motion"]) {
              pkg.dependencies["framer-motion"] = "latest";
              changed = true;
            }
            if (needsSlot && !pkg.dependencies["@radix-ui/react-slot"]) {
              pkg.dependencies["@radix-ui/react-slot"] = "latest";
              changed = true;
            }
            if (changed) {
              const nextRaw = JSON.stringify(pkg, null, 2) + "\n";
              await sandbox.files.write(pkgPath, nextRaw);
              result.state.data.files[pkgPath] = nextRaw;
              // Install deps in sandbox so preview can run animations
              try {
                await sandbox.commands.run("npm i --no-audit --no-fund");
              } catch (e) {
                console.warn("sandbox npm install failed", e);
              }
            }
          }
        } catch (e) {
          console.warn("postprocess: ensure animation deps failed", e);
        }
      });
    }

    // Reconcile: ensure all in-memory files exist in the sandbox before composing the page
    await step.run("reconcile-files-to-sandbox", async () => {
      try {
        const sandbox = await getSandbox(sandboxId);
        const files = (result.state.data.files || {}) as Record<string, string>;
        for (const [p, c] of Object.entries(files)) {
          try {
            await sandbox.files.read(p);
          } catch {
            await sandbox.files.write(p, String(c ?? ""));
          }
        }
      } catch (e) {
        console.warn("reconcile-files-to-sandbox (create) failed", e);
      }
    });

    // Ensure a root page exists or repair if default template before exposing URL
    await step.run("ensure-root-page", async () => {
      try {
        const files = (result.state.data.files || {}) as Record<string, string>;
        const sandbox = await getSandbox(sandboxId);
        const hasSrc = Object.keys(files).some((p) => p.startsWith("src/"));
        const pagePath = hasSrc ? "src/app/page.tsx" : "app/page.tsx";
        let pageRaw = "";
        try { pageRaw = await sandbox.files.read(pagePath); } catch {}
        const isDefault = !!pageRaw && DEFAULT_NEXT_TEMPLATE_RE.test(pageRaw);
        const missing = !pageRaw;
        if (!missing && !isDefault) return;

        // Build imports + body from existing app sections that expose a named export matching file name
        const candidates = Object.entries(files)
          .filter(([p]) => /^(src\/)?app\/.+\.tsx$/i.test(p) && !/\b(page|layout)\.tsx$/i.test(p))
          .map(([p, content]) => ({ p, content: String(content || "") }));

        const pick = (names: string[]) => candidates.find((c) => names.some((n) => new RegExp(`(^|\/)${n}\.tsx$`, "i").test(c.p)));
        const ordered: { name: string; rel: string; content: string }[] = [];
        const pushIf = (base: string) => {
          const hit = candidates.find((c) => new RegExp(`(^|\/)${base}\.tsx$`, "i").test(c.p));
          if (!hit) return;
          const name = base.replace(/\.tsx$/i, "");
          if (new RegExp(`export\s+(function|const|class)\s+${name}\b`).test(hit.content)) {
            const rel = `./${name}`;
            ordered.push({ name, rel, content: hit.content });
          }
        };
        // Prefer common sections first
        pushIf("Navbar");
        pushIf("HeroBanner");
        // Add a few more common names if present
        ["Header","Hero","CallToAction","Features","Pricing","Testimonials","Clients","Gallery","VideoSection","Contact","Footer"].forEach(pushIf);
        // If nothing matched from in-memory files, try reading common sections directly from sandbox
        if (ordered.length === 0) {
          const common = ["Navbar","HeroBanner","Header","Hero","CallToAction","Features","Pricing","Testimonials","Clients","Gallery","VideoSection","Contact","Footer"];
          for (const base of common) {
            const p = `${hasSrc ? "src/" : ""}app/${base}.tsx`;
            try {
              const src = await sandbox.files.read(p);
              if (src && new RegExp(`export\\s+(function|const|class)\\s+${base}\\b`).test(src)) {
                ordered.push({ name: base, rel: `./${base}`, content: src });
              }
            } catch {}
          }
        }

        // Fallback: if nothing matched, create minimal page
        const imports = ordered.map((o) => `import { ${o.name} } from '${o.rel}';`).join("\n");
        const body = ordered.map((o) => `      <${o.name} />`).join("\n");
        const composed = `"use client";\n${imports ? imports + "\n\n" : ""}export default function Page(){\n  return (\n    <main className=\"min-h-screen w-full flex flex-col\">\n${body || "      <div />"}\n    </main>\n  );\n}\n`;
        await sandbox.files.write(pagePath, composed);
        files[pagePath] = composed;
        (result.state.data.files as any) = files;
      } catch (e) {
        console.warn("ensure-root-page (create) failed", e);
      }
    });

    // Snapshot essential files (like app/src app page) after ensuring final page content
    await step.run("snapshot-essential-files", async () => {
      try {
        const sandbox = await getSandbox(sandboxId);
        const candidates = ["app/page.tsx", "src/app/page.tsx"];
        for (const p of candidates) {
          try {
            const src = await sandbox.files.read(p);
            if (src && typeof src === "string") {
              (result.state.data.files as any)[p] = src;
            }
          } catch {}
        }
      } catch (e) {
        console.warn("snapshot-essential-files (create) failed", e);
      }
    });

    const sandboxUrl = await step.run("get-sandbox-url", async () => {
      console.log("Running get-sandbox-url");
      const sandbox = await getSandbox(sandboxId);
      const host = sandbox.getHost(3000);
      console.log("Completed get-sandbox-url", host);
      return `https://${host}`;
    });

  await step.run("save-result", async () => {
      console.log("Running save-result");
      if (isError) {
        const errorMessage = await prisma.message.create({
          data: {
            projectId: event.data.projectId,
            content: "Alguam coisa deu errado. Tente novamente.",
            role: "ASSISTANT",
            type: "ERROR",
          },
        });
        console.log("Completed save-result with error", errorMessage.id);
        return errorMessage;
      }

  const successMessage = await prisma.message.create({
        data: {
          projectId: event.data.projectId,
          content: parseAgentOutput(responseOutput),
          role: "ASSISTANT",
          type: "RESULT",
          fragment: {
            create: {
              sandboxUrl,
              title: parseAgentOutput(fragmentTitleOutput),
              files: result.state.data.files,
            },
          },
        },
      });
      console.log("Completed save-result with success", successMessage.id);
      return successMessage;
    });
    console.log("Completed code-agent function");
    return {
      url: sandboxUrl,
      title: "Fragment",
      files: result.state.data.files,
      summary: result.state.data.summary,
    };
  }
);

export const codeAgentEditFunction = inngest.createFunction(
  { id: "code-agent-edit" },
  { event: "code-agent/edit" },
  async ({ event, step }) => {
    console.log("Starting code-agent-edit", JSON.stringify(event.data));
    const sandboxId = await getOrCreateSandboxId(step);

    // Load last fragment files for this project
    const existing = await step.run("load-existing-files", async () => {
      const last = await prisma.message.findFirst({
        where: {
          projectId: (event.data as any).projectId,
          role: "ASSISTANT",
          type: "RESULT",
          fragment: { isNot: null },
        },
        include: { fragment: true },
        orderBy: { createdAt: "desc" },
      });
      const files = ((last as any)?.fragment?.files as FileCollection | undefined) || {};
      // Harden: if previous fragment missed app/src page.tsx, synthesize one from known sections
      try {
        const hasSrc = Object.keys(files).some((p) => p.startsWith("src/"));
        const pagePath = hasSrc ? "src/app/page.tsx" : "app/page.tsx";
        if (!files[pagePath]) {
          const candidates = Object.entries(files)
            .filter(([p]) => /^(src\/)?app\/.+\.tsx$/i.test(p) && !/\b(page|layout)\.tsx$/i.test(p))
            .map(([p, content]) => ({ p, content: String(content || "") }));
          const ordered: { name: string; rel: string; content: string }[] = [];
          const pushIf = (base: string) => {
            const hit = candidates.find((c) => new RegExp(`(^|\/)${base}\.tsx$`, "i").test(c.p));
            if (!hit) return;
            const name = base.replace(/\.tsx$/i, "");
            if (new RegExp(`export\\s+(function|const|class)\\s+${name}\\b`).test(hit.content)) {
              const rel = `./${name}`;
              ordered.push({ name, rel, content: hit.content });
            }
          };
          [
            "Navbar",
            "HeroBanner",
            "Header",
            "Hero",
            "CallToAction",
            "Features",
            "Pricing",
            "Testimonials",
            "Clients",
            "Gallery",
            "VideoSection",
            "Contact",
            "Footer",
          ].forEach(pushIf);
          const imports = ordered.map((o) => `import { ${o.name} } from '${o.rel}';`).join("\n");
          const body = ordered.map((o) => `      <${o.name} />`).join("\n");
          const composed = `"use client";\n${imports ? imports + "\n\n" : ""}export default function Page(){\n  return (\n    <main className=\"min-h-screen w-full flex flex-col\">\n${body || "      <div />"}\n    </main>\n  );\n}\n`;
          files[pagePath] = composed;
        }
      } catch {}
      return files;
    });

    // Hydrate sandbox with existing files
    await step.run("hydrate-sandbox", async () => {
      const sandbox = await getSandbox(sandboxId);
      for (const [path, content] of Object.entries(existing)) {
        try {
          await sandbox.files.write(path, content as string);
        } catch (e) {
          console.warn("hydrate write failed", path, e);
        }
      }
    });

    const previousMessages: Message[] = [];
    const state = createState<AgentState>(
      {
        summary: "",
        files: { ...existing },
        allowedPaths: [],
      },
      { messages: previousMessages }
    );

    const hasSrc = Object.keys(existing).some((p) => p.startsWith("src/"));
    const userText = String((event.data as any).value || "");
    // Hint de arquivo do bloco de código: ```tsx nome
    const codeFencePathMatch = userText.match(/```(?:tsx|ts|jsx|js)\s+([^\s`]+)/i);
    const codeFencePath = codeFencePathMatch?.[1];
    // Imports citados
    const importPaths = Array.from(userText.matchAll(/from\s+["'`](.*?)["'`]/g)).map((m) => m[1]);
    const hintedPathsSet = new Set<string>();
    if (codeFencePath) hintedPathsSet.add(codeFencePath);
    importPaths.forEach((p) => hintedPathsSet.add(p));
    const hintedAllowed = Array.from(hintedPathsSet)
      .map((p) => normalizeSandboxPath(p, hasSrc))
      .filter(Boolean);

    // Impact analyzer to select minimal set of files
    const impactAnalyzer = createAgent<AgentState>({
      name: "impact-analyzer",
      description: "Select minimal impacted files for the change request",
      system:
        "You are an impact analyzer. Given a change request and a file map, return a compact JSON array of file paths to modify. Rules:\n- Select the smallest set of files that must change to implement the request.\n- Do not include files that do not need edits.\n- Output ONLY a JSON array of strings (no markdown, no commentary).",
      model: azureOpenAICompat({
        endpoint: process.env.AZURE_OPENAI_ENDPOINT!,
        apiKey: process.env.AZURE_OPENAI_5_API_KEY || process.env.AZURE_OPENAI_API_KEY!,
        deployment: process.env.AZURE_OPENAI_5_DEPLOYMENT || process.env.AZURE_OPENAI_DEPLOYMENT!,
        apiVersion: process.env.AZURE_OPENAI_5_API_VERSION || process.env.AZURE_OPENAI_API_VERSION!,
        defaultParameters: { temperature: 0.1 },
      }),
    });

    const fileIndex = Object.keys(existing).slice(0, 2000);
    const analyzerInput = JSON.stringify({
      request: (event.data as any).value,
      files: fileIndex,
    });
    const { output: impactOutput } = await impactAnalyzer.run(analyzerInput);
    let allowedPaths: string[] = [];
    try {
      const text = impactOutput
        .filter((m: any) => m.type === "text")
        .map((m: any) => (m as any).content)
        .join("");
      const parsed = JSON.parse(Array.isArray(text) ? (text as any).join("") : text);
      if (Array.isArray(parsed)) {
        allowedPaths = parsed.filter((p) => typeof p === "string");
      }
    } catch (e) {
      console.warn("impact parse failed, using heuristic fallback", e);
    }

    if (allowedPaths.length === 0) {
      allowedPaths = fileIndex.filter((p) => /\.(tsx|ts|jsx|js)$/.test(p)).slice(0, 5);
    }
    // Une com os caminhos sugeridos pelo usuário
    const union = new Set<string>([...allowedPaths, ...hintedAllowed]);
    // Normalize todos os caminhos permitidos de acordo com a estrutura (src/ ou não)
    const normalizedAllowed = new Set<string>();
    for (const p of Array.from(union)) {
      try {
        normalizedAllowed.add(normalizeSandboxPath(p, hasSrc));
      } catch {
        // ignora caminhos inválidos
      }
    }
  // Garante que a página principal sempre pode ser editada (single-page landing)
  normalizedAllowed.add(hasSrc ? "src/app/page.tsx" : "app/page.tsx");
  // Permite criar/editar seções na pasta app/
  normalizedAllowed.add(hasSrc ? "src/app/*" : "app/*");
    const finalAllowed = Array.from(normalizedAllowed);
    state.data.allowedPaths = finalAllowed;

    const enrichedInstructionForSteps = [
      (event.data as any).value,
      `Only edit: ${(state.data.allowedPaths || []).join(", ")}`,
    ]
      .filter(Boolean)
      .join("\n\n");

    const taskStepsGenerator = createTaskStepsAgent();

    const { output: taskStepsOutput } = await taskStepsGenerator.run(
      enrichedInstructionForSteps
    );
    logAssistantTexts("task-steps-generator", taskStepsOutput);
    console.log("Completed taskStepsGenerator.run for edit");

    await step.run("save-steps-for-edit", async () => {
      console.log("Running save-steps-for-edit");
      const stepsMessage = await prisma.message.create({
        data: {
          projectId: (event.data as any).projectId,
          content: parseAgentOutput(taskStepsOutput),
          role: "ASSISTANT",
          type: "STEPS",
        },
      });
      console.log("Completed save-steps-for-edit", stepsMessage.id);
      return stepsMessage;
    });

    // Editor agent uses dedicated EDIT_PROMPT to enforce non-destructive edits
    const editorAgent = createAgent<AgentState>({
      name: "code-editor",
      description: "Edit only the allowed files for the requested change",
  system: `${EDIT_PROMPT}\n\nAllowed files:\n${(state.data.allowedPaths || []).map((p) => `- ${p}`).join("\n")}`,
      model: azureOpenAICompat({
        endpoint: process.env.AZURE_OPENAI_ENDPOINT!,
        apiKey: process.env.AZURE_OPENAI_5_API_KEY || process.env.AZURE_OPENAI_API_KEY!,
        deployment: process.env.AZURE_OPENAI_5_DEPLOYMENT || process.env.AZURE_OPENAI_DEPLOYMENT!,
        apiVersion: process.env.AZURE_OPENAI_5_API_VERSION || process.env.AZURE_OPENAI_API_VERSION!,
        defaultParameters: { temperature: 0.1 },
      }),
      tools: [
        // Reuse tools from main agent by redefining here
        createTool({
          name: "terminal",
          description: "Use the terminal to run commands",
          parameters: z.object({ command: z.string() }),
          handler: async ({ command }, { step }) => {
            return await step?.run("terminal", async () => {
              const buffers = { stdout: "", stderr: "" };
              try {
                const sandbox = await getSandbox(sandboxId);
                const result = await sandbox.commands.run(command, {
                  onStdout: (d: string) => {
                    buffers.stdout += d;
                  },
                  onStderr: (d: string) => {
                    buffers.stderr += d;
                  },
                });
                return result.stdout;
              } catch (error) {
                return `command failed: ${error}\nstdOut: ${buffers.stdout}\nstdError: ${buffers.stderr}`;
              }
            });
          },
        }),
        createTool({
          name: "createOrUpdateFiles",
          description: "Create or update files in the sandbox",
          parameters: z.object({
            files: z.array(z.object({ path: z.string(), content: z.string() })),
          }),
          handler: async ({ files }, { step, network }) => {
            const newFiles = await step?.run("createOrUpdateFiles", async () => {
              try {
                const updatedFiles = network.state.data.files || {};
                const sandbox = await getSandbox(sandboxId);
                const hasSrc = Object.keys(updatedFiles).some((p) => p.startsWith("src/"));
                const guard = new Set<string>((network.state.data.allowedPaths || []) as string[]);
                for (const file of files) {
                  let normalized = normalizeSandboxPath(file.path, hasSrc);
                  normalized = mapComponentPath(normalized);
                  if (!isPathAllowed(normalized, guard)) {
                    console.warn(`[edit-guard] blocked write to ${normalized}`);
                    continue;
                  }
                  if (/\/demo\.(tsx|jsx|ts|js)$/i.test(normalized)) {
                    console.warn(`[policy] demo files are not allowed: ${normalized}`);
                    continue;
                  }
                  // Light guard: prevent removing critical sections inadvertently
                  if (/^app\/page\.(tsx|jsx|ts|js)$/i.test(normalized)) {
                    const prev = typeof updatedFiles[normalized] === "string"
                      ? (updatedFiles[normalized] as string)
                      : await (async () => { try { return await sandbox.files.read(normalized); } catch { return ""; } })();
                    if (prev) {
                      const v = violatesCriticalSections(prev, file.content);
                      if (v) return `Blocked edit to ${normalized}: ${v}`;
                    }
                  }
                  const finalContent = normalizeAppFileContent(normalized, file.content);
                  await sandbox.files.write(normalized, finalContent);
                  updatedFiles[normalized] = finalContent;
                }
                return updatedFiles;
              } catch (error) {
                return "Error: " + error;
              }
            });
            if (typeof newFiles === "object") {
              const prev = (network.state.data.files || {}) as Record<string, string>;
              (network as any).state.data.files = { ...prev, ...(newFiles as any) } as any;
            }
          },
        }),
        createTool({
          name: "safeUpdatePage",
          description: "Non-destructive update for app/page.*. Inserts a component into <main> and ensures import; preserves the rest of the file.",
          parameters: z.object({
            filePath: z.string().default("app/page.tsx"),
            importLine: z.string(),
            jsx: z.string(),
            position: z.enum(["prepend", "append"]).default("append"),
          }),
          handler: async ({ filePath, importLine, jsx, position }, { step, network }) => {
            return await step?.run("safeUpdatePage", async () => {
              const sandbox = await getSandbox(sandboxId);
              const filesState = (network.state.data.files || {}) as Record<string, string>;
              const hasSrc = Object.keys(filesState).some((p) => p.startsWith("src/")) ||
                (await (async () => { try { await sandbox.files.read("src/app/page.tsx"); return true; } catch { return false; } })());
              const path = normalizeSandboxPath(filePath, hasSrc);
              const guard = new Set<string>((network.state.data.allowedPaths || []) as string[]);
              if (!isPathAllowed(path, guard)) return `Blocked: ${path} not in allowedPaths.`;
              let prev = "";
              try { prev = await sandbox.files.read(path); } catch {}
              if (!prev) {
                prev = `"use client";\n\nexport default function Page(){\n  return (<main className=\"min-h-screen w-full\">{\"\"}</main>);\n}\n`;
              }
              const importPreferred = sanitizeUiImportToApp(importLine, filesState);
              const sanitized = sanitizeDemoImport(importPreferred, jsx, filesState);
              const adjusted = ensureUniqueAlias(sanitized.importLine, prev, sanitized.jsx);
              const fixedImport = adjusted.importLine;
              const fixedJsx = adjusted.jsx;
              let next = ensureImportLine(prev, fixedImport);
              next = insertJsxIntoMain(next, fixedJsx, position);
              await sandbox.files.write(path, next);
              network.state.data.files[path] = next;
              return `Updated ${path} with safe merge`;
            });
          },
        }),
        createTool({
          name: "readFiles",
          description: "Read files from the sandbox",
          parameters: z.object({ files: z.array(z.string()) }),
          handler: async ({ files }, { step }) => {
            return await step?.run("readFiles", async () => {
              try {
                const sandbox = await getSandbox(sandboxId);
                const contents: any[] = [];
                // Usa presença de src/ no sandbox a partir do estado do editor (poderia estar vazio, cairá em false)
                // Não temos network aqui, então fazemos tentativa com heurística básica: se caminho começa com '@/'
                const hasSrcHeuristic = files.some((p) => p.startsWith("@/"));
                for (const f of files) {
                  const p = normalizeSandboxPath(f, hasSrcHeuristic);
                  try {
                    const content = await sandbox.files.read(p);
                    contents.push({ path: p, content });
                  } catch (e: any) {
                    const msg = String(e?.message || e);
                    if (/NotFound/i.test(msg)) {
                      console.warn(`[readFiles] not found: ${p}`);
                      contents.push({ path: p, content: null });
                      continue;
                    }
                    throw e;
                  }
                }
                return JSON.stringify(contents);
              } catch (error) {
                return "Error: " + error;
              }
            });
          },
        }),
      ],
      lifecycle: {
        onResponse: async ({ result, network }) => {
          logAssistantTexts("code-editor", result.output);
          const lastAssistantTextMessageText = lastAssistantTextMessageContent(result);
          if (lastAssistantTextMessageText && network) {
            if (lastAssistantTextMessageText.includes("<task_summary>")) {
              network.state.data.summary = lastAssistantTextMessageText;
            }
          }
          return result;
        },
      },
    });

    const editorNetwork = createNetwork<AgentState>({
      name: "coding-editor-network",
      agents: [editorAgent],
      maxIter: 12,
      defaultState: state,
      router: async ({ network }) => {
        const summary = network.state.data.summary;
        if (summary) return;
        return editorAgent;
      },
    });

    const enrichedInstruction = [
      (event.data as any).value,
      `Only edit: ${(state.data.allowedPaths || []).join(", ")}`,
    ]
      .filter(Boolean)
      .join("\n\n");

    const result = await editorNetwork.run(enrichedInstruction, { state });

    const fragmentTitleGenerator = createFragmentTitleAgentDefault();
    const responseGenerator = createResponseAgentDefault();

    const { output: fragmentTitleOutput } = await fragmentTitleGenerator.run(
      result.state.data.summary
    );
    const { output: responseOutput } = await responseGenerator.run(
      result.state.data.summary
    );

    // Ensure project metadata (title/description) in app/layout.* for edit flow
    await ensureMetadataStep(step, result, sandboxId, "LandingPage", "Landing Page criada no Landinfy.com");

    const isError =
      !result.state.data.summary ||
      Object.keys(result.state.data.files || {}).length === 0;

    // Reconcile: ensure all in-memory files exist in the sandbox before composing the page
    await step.run("reconcile-files-to-sandbox", async () => {
      try {
        const sandbox = await getSandbox(sandboxId);
        const files = (result.state.data.files || {}) as Record<string, string>;
        for (const [p, c] of Object.entries(files)) {
          try {
            await sandbox.files.read(p);
          } catch {
            await sandbox.files.write(p, String(c ?? ""));
          }
        }
      } catch (e) {
        console.warn("reconcile-files-to-sandbox (edit) failed", e);
      }
    });

    // Ensure a root page exists or repair if default template before exposing URL
    await step.run("ensure-root-page", async () => {
      try {
        const files = (result.state.data.files || {}) as Record<string, string>;
        const sandbox = await getSandbox(sandboxId);
        const hasSrc = Object.keys(files).some((p) => p.startsWith("src/"));
        const pagePath = hasSrc ? "src/app/page.tsx" : "app/page.tsx";
        let pageRaw = "";
        try { pageRaw = await sandbox.files.read(pagePath); } catch {}
        const isDefault = !!pageRaw && DEFAULT_NEXT_TEMPLATE_RE.test(pageRaw);
        const missing = !pageRaw;
        if (!missing && !isDefault) return;

        const candidates = Object.entries(files)
          .filter(([p]) => /^(src\/)?app\/.+\.tsx$/i.test(p) && !/\b(page|layout)\.tsx$/i.test(p))
          .map(([p, content]) => ({ p, content: String(content || "") }));

        const ordered: { name: string; rel: string; content: string }[] = [];
        const pushIf = (base: string) => {
          const hit = candidates.find((c) => new RegExp(`(^|\/)${base}\.tsx$`, "i").test(c.p));
          if (!hit) return;
          const name = base.replace(/\.tsx$/i, "");
          if (new RegExp(`export\s+(function|const|class)\s+${name}\b`).test(hit.content)) {
            const rel = `./${name}`;
            ordered.push({ name, rel, content: hit.content });
          }
        };
        ["Navbar","HeroBanner","Header","Hero","CallToAction","Features","Pricing","Testimonials","Clients","Gallery","VideoSection","Contact","Footer"].forEach(pushIf);
        if (ordered.length === 0) {
          const common = ["Navbar","HeroBanner","Header","Hero","CallToAction","Features","Pricing","Testimonials","Clients","Gallery","VideoSection","Contact","Footer"];
          for (const base of common) {
            const p = `${hasSrc ? "src/" : ""}app/${base}.tsx`;
            try {
              const src = await sandbox.files.read(p);
              if (src && new RegExp(`export\\s+(function|const|class)\\s+${base}\\b`).test(src)) {
                ordered.push({ name: base, rel: `./${base}`, content: src });
              }
            } catch {}
          }
        }
        const imports = ordered.map((o) => `import { ${o.name} } from '${o.rel}';`).join("\n");
        const body = ordered.map((o) => `      <${o.name} />`).join("\n");
        const composed = `"use client";\n${imports ? imports + "\n\n" : ""}export default function Page(){\n  return (\n    <main className=\"min-h-screen w-full flex flex-col\">\n${body || "      <div />"}\n    </main>\n  );\n}\n`;
        await sandbox.files.write(pagePath, composed);
        files[pagePath] = composed;
        (result.state.data.files as any) = files;
      } catch (e) {
        console.warn("ensure-root-page (edit) failed", e);
      }
    });

    // Snapshot essential files (like app/src app page) after ensuring final page content
    await step.run("snapshot-essential-files", async () => {
      try {
        const sandbox = await getSandbox(sandboxId);
        const candidates = ["app/page.tsx", "src/app/page.tsx"];
        for (const p of candidates) {
          try {
            const src = await sandbox.files.read(p);
            if (src && typeof src === "string") {
              (result.state.data.files as any)[p] = src;
            }
          } catch {}
        }
      } catch (e) {
        console.warn("snapshot-essential-files (edit) failed", e);
      }
    });

    const sandboxUrl = await step.run("get-sandbox-url", async () => {
      const sandbox = await getSandbox(sandboxId);
      const host = sandbox.getHost(3000);
      return `https://${host}`;
    });

    await step.run("save-result", async () => {
      if (isError) {
        await prisma.message.create({
          data: {
            projectId: (event.data as any).projectId,
            content: "Alguma coisa deu errado, tente novamente! ",
            role: "ASSISTANT",
            type: "ERROR",
          },
        });
        return;
      }

      await prisma.message.create({
        data: {
          projectId: (event.data as any).projectId,
          content: parseAgentOutput(responseOutput),
          role: "ASSISTANT",
          type: "RESULT",
          fragment: {
            create: {
              sandboxUrl,
              title: parseAgentOutput(fragmentTitleOutput),
              files: result.state.data.files,
            },
          },
        },
      });
    });

    return {
      url: sandboxUrl,
      title: "Fragment",
      files: result.state.data.files,
      summary: result.state.data.summary,
    };
  }
);
